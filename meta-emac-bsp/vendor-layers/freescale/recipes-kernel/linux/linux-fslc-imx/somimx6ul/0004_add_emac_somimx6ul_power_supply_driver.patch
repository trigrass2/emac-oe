diff --git a/Documentation/devicetree/bindings/power/supply/lltc,lt8491-charger.yaml b/Documentation/devicetree/bindings/power/supply/lltc,lt8491-charger.yaml
new file mode 100644
index 000000000000..d8948ea5d557
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/supply/lltc,lt8491-charger.yaml
@@ -0,0 +1,112 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: "http://devicetree.org/schemas/power/supply/lltc,lt8491-charger.yaml#"
+$schema: "http://devicetree.org/meta-schemas/core.yaml#"
+
+title: Analog Devices LT8491 Charger Power Supply bindings
+
+maintainers:
+  - Brenden Tisler <btisler@emacinc.com>
+
+allOf:
+  - $ref: power-supply.yaml#
+
+properties:
+  compatible:
+    enum:
+      - lltc,lt8491-charger
+  
+  reg:
+    maxItems: 1
+
+  chip-enable-gpios:
+    maxItems: 1
+    
+  enable-at-boot:
+    type: bool
+    description: Flag to enable to chip gpio on probe
+
+  unique-conf-id:
+    const: ""
+    description: ""
+  rsense1:
+    const: ""
+    description: ""
+  rimon_out:
+    const: ""
+    description: ""
+  rsense2:
+    const: ""
+    description: ""
+  rdaco:
+    const: ""
+    description: ""
+  rfbout1:
+    const: ""
+    description: ""
+  rfbout2:
+    const: ""
+    description: ""
+  rdaci:
+    const: ""
+    description: ""
+  rfbin1:
+    const: ""
+    description: ""
+  rfbin2:
+    const: ""
+    description: ""
+  vs3_25c:
+    const: ""
+    description: ""
+  uv_s0:
+    const: ""
+    description: ""
+  s0_uv:
+    const: ""
+    description: ""
+  s0_s1:
+    const: ""
+    description: ""
+  s1_s0:
+    const: ""
+    description: ""
+  misc_use_vs3_in_s2:
+    const: ""
+    description: ""
+  misc_lpmode_en:
+    const: ""
+    description: ""
+  misc_ps_s3_en:
+    const: ""
+    description: ""
+  tbat_min:
+    const: ""
+    description: ""
+  tbat_max:
+    const: ""
+    description: ""
+  rstrt_in_donea:
+    const: ""
+    description: ""
+  terminate:
+    const: ""
+    description: ""
+
+required:
+  - compatible
+  - reg
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    battcharger {
+      compatible = "lltc,lt8491";
+      reg = <0x29>;
+      chip-enable-gpios = <&gpio4 9 GPIO_ACTIVE_LOW>;
+      enable-at-boot;
+      status = "okay";
+    };
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index eb7034f5bb05..a960f8745190 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -522,6 +522,14 @@ config CHARGER_LT3651
 	  Say Y to include support for the Analog Devices (Linear Technology)
 	  LT3651 battery charger which reports its status via GPIO lines.
 
+config CHARGER_LT8491
+	tristate "Analog Devices LT8491 charger"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  Say Y to include support for the Analog Devices (Linear Technology)
+	  LT8491 battery charger.
+
 config CHARGER_LTC4162L
 	tristate "LTC4162-L charger"
 	depends on I2C
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index 0d3dc2a6d23f..0f2bae52815b 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -71,6 +71,7 @@ obj-$(CONFIG_CHARGER_LP8788)	+= lp8788-charger.o
 obj-$(CONFIG_CHARGER_GPIO)	+= gpio-charger.o
 obj-$(CONFIG_CHARGER_MANAGER)	+= charger-manager.o
 obj-$(CONFIG_CHARGER_LT3651)	+= lt3651-charger.o
+obj-$(CONFIG_CHARGER_LT8491)   += lt8491-charger.o
 obj-$(CONFIG_CHARGER_LTC4162L)	+= ltc4162-l-charger.o
 obj-$(CONFIG_CHARGER_MAX14577)	+= max14577_charger.o
 obj-$(CONFIG_CHARGER_DETECTOR_MAX14656)	+= max14656_charger_detector.o
diff --git a/drivers/power/supply/lt8491-charger.c b/drivers/power/supply/lt8491-charger.c
new file mode 100644
index 000000000000..e830c519b2fc
--- /dev/null
+++ b/drivers/power/supply/lt8491-charger.c
@@ -0,0 +1,973 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * I2C client/driver for the Linear Technology LT8491
+ * Battery Charger IC
+ *
+ * Copyright (C) 2022 EMAC Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/swab.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/gpio/consumer.h>
+
+#include "lt8491-charger.h"
+
+struct lt8491_device {
+	enum lt8491_chip chip;
+	struct i2c_client *client;
+	struct device *dev;
+	struct power_supply *charger;
+	struct power_supply *battery;
+
+	bool enabled_state;
+	struct gpio_desc *enable;
+
+	struct regmap *tele_regmap;
+	struct regmap *statb_regmap;
+	struct regmap *statw_regmap;
+	struct regmap *ctrl_regmap;
+	struct regmap *confb_regmap;
+	struct regmap *confw_regmap;
+	struct regmap *conflw_regmap;
+	struct regmap *mfgr_regmap;
+	struct regmap *bootb_regmap;
+	struct regmap *bootw_regmap;
+	struct regmap *bootlw_regmap;
+	struct regmap_field *tele_rmap_fields[F_TELE_MAX];
+	struct regmap_field *statb_rmap_fields[F_STATB_MAX];
+	struct regmap_field *statw_rmap_fields[F_STATW_MAX];
+	struct regmap_field *ctrl_rmap_fields[F_CTRL_MAX];
+	struct regmap_field *confb_rmap_fields[F_CONFB_MAX];
+	struct regmap_field *confw_rmap_fields[F_CONFW_MAX];
+	struct regmap_field *conflw_rmap_fields[F_CONFLW_MAX];
+	struct regmap_field *mfgr_rmap_fields[F_MFR_MAX];
+	struct regmap_field *bootb_rmap_fields[F_BOOTB_MAX];
+	struct regmap_field *bootw_rmap_fields[F_BOOTW_MAX];
+	struct regmap_field *bootlw_rmap_fields[F_BOOTLW_MAX];
+};
+static int lt8491_hw_init(struct lt8491_device *ltdev);
+
+static bool lt8491_is_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static int lt8491_field_read(struct lt8491_device *ltdev,  enum lt8491_regmaps map_id,
+			      int field_id, unsigned int *val)
+{
+	int ret = -EINVAL;
+	switch (map_id) {
+	case LT8491_TELE_REGMAP:
+		ret = regmap_field_read(ltdev->tele_rmap_fields[field_id], val);
+                break;
+	case LT8491_STAT_REGMAP_B:
+		ret = regmap_field_read(ltdev->statb_rmap_fields[field_id], val);
+                break;
+	case LT8491_STAT_REGMAP_W:
+		ret =  regmap_field_read(ltdev->statw_rmap_fields[field_id], val);
+                break;
+	case LT8491_CTRL_REGMAP:
+		ret =  regmap_field_read(ltdev->ctrl_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_B:
+		ret =  regmap_field_read(ltdev->confb_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_W:
+		ret =  regmap_field_read(ltdev->confw_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_LW:
+		ret =  regmap_field_read(ltdev->conflw_rmap_fields[field_id], val);
+                break;
+	case LT8491_MFGR_REGMAP:
+		ret =  regmap_field_read(ltdev->mfgr_rmap_fields[field_id], val);
+		break;
+	case LT8491_BOOT_REGMAP_B:
+		ret = regmap_field_read(ltdev->bootb_rmap_fields[field_id], val);
+		break;
+	case LT8491_BOOT_REGMAP_W:
+		ret = regmap_field_read(ltdev->bootw_rmap_fields[field_id], val);
+		break;
+	case LT8491_BOOT_REGMAP_LW:
+		ret = regmap_field_read(ltdev->bootlw_rmap_fields[field_id], val);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	dev_dbg(ltdev->dev, "read mapid: %d, fieldid: %d, ret: %d, val: %x", (int)map_id, field_id, ret, *val);
+	return ret;
+}
+
+static int lt8491_field_write(struct lt8491_device *ltdev, enum lt8491_regmaps map_id,
+			       int field_id, unsigned int val)
+{
+	int ret = -EINVAL;
+	switch (map_id) {
+	case LT8491_TELE_REGMAP:
+		ret = regmap_field_write(ltdev->tele_rmap_fields[field_id], val);
+                break;
+	case LT8491_STAT_REGMAP_B:
+		ret = regmap_field_write(ltdev->statb_rmap_fields[field_id], val);
+                break;
+	case LT8491_STAT_REGMAP_W:
+		ret = regmap_field_write(ltdev->statw_rmap_fields[field_id], val);
+                break;
+	case LT8491_CTRL_REGMAP:
+		ret = regmap_field_write(ltdev->ctrl_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_B:
+		ret = regmap_field_write(ltdev->confb_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_W:
+		ret = regmap_field_write(ltdev->confw_rmap_fields[field_id], val);
+                break;
+	case LT8491_CONF_REGMAP_LW:
+		ret = regmap_field_write(ltdev->conflw_rmap_fields[field_id], val);
+                break;
+	case LT8491_MFGR_REGMAP:
+		ret = regmap_field_write(ltdev->mfgr_rmap_fields[field_id], val);
+                break;
+	case LT8491_BOOT_REGMAP_B:
+		ret = regmap_field_write(ltdev->bootb_rmap_fields[field_id], val);
+                break;
+	case LT8491_BOOT_REGMAP_W:
+		ret = regmap_field_write(ltdev->bootw_rmap_fields[field_id], val);
+                break;
+	case LT8491_BOOT_REGMAP_LW:
+		ret = regmap_field_write(ltdev->bootlw_rmap_fields[field_id], val);
+                break;
+	default:
+		ret = -EINVAL;
+	}
+	dev_dbg(ltdev->dev, "write mapid: %d, fieldid: %d, ret: %d, val: %x", (int)map_id, field_id, ret, val);
+	return ret;
+}
+
+static bool lt8491_system_is_busy(struct lt8491_device *ltdev){
+	unsigned int val;
+	if (regmap_field_read(ltdev->statb_rmap_fields[F_STAT_SYSTEM_BUSY], &val) < 0){
+		return true;
+	}
+	return (bool) val;
+}
+
+static bool lt8491_charge_is_enabled(struct lt8491_device *ltdev){
+	unsigned int val;
+	if (regmap_field_read(ltdev->ctrl_rmap_fields[F_CTRL_CHRG_EN], &val) < 0){
+		return true;
+	}
+	return (bool) val;
+}
+
+static void lt8491_set_enable_gpio(struct lt8491_device *ltdev, int value){
+	if (ltdev->enable){
+		ltdev->enabled_state = (bool)value;
+		gpiod_set_value(ltdev->enable, value);
+	}
+	return;
+}
+
+// --------------------------------------
+
+static int lt8491_charger_get_property(struct power_supply *psy,
+					     enum power_supply_property psp,
+					     union power_supply_propval *val)
+{
+	struct lt8491_device *ltdev = power_supply_get_drvdata(psy);
+	unsigned int uval;
+	unsigned int uval_lsb;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT: // 1 if present, else 0
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VIN_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VIN_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		uval = ((uval & 0xFF) << 8) | (uval_lsb & 0xFF);
+		if (uval > 0){
+			val->intval = 1;
+		}
+		else {
+			val->intval = 0;
+		}
+		break;
+	case POWER_SUPPLY_PROP_STATUS: // 1 if charging, else 0
+		if (lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, (int)F_STAT_CHARGING, &uval) < 0){
+			return -EINVAL;
+		}
+		if (uval > 0){
+			val->intval = 1;
+		}
+		else {
+			val->intval = 0;
+		}
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_TYPE: // Charging state
+		if (lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, (int)F_STAT_CHRG_STAGE, &uval) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)uval;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW: // TELE_VIN for dc power, value in microvolts
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VIN_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VIN_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int) (((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 10000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW: // TELE_IIN, value in microamps
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_IIN_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_IIN_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int) (((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 1000;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW: // TELE_PIN, value in microwatts
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_PIN_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if ( lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_PIN_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int) (((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 10000;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property lt8491_power_supply_charger_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+};
+
+static char *lt8491_charger_supplied_to[] = {
+	"battery",
+};
+
+static const struct power_supply_desc lt8491_power_supply_charger_desc = {
+	.name = "lt8491-charger",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.properties = lt8491_power_supply_charger_props,
+	.num_properties = ARRAY_SIZE(lt8491_power_supply_charger_props),
+	.get_property = lt8491_charger_get_property,
+};
+
+#define READ_CFG_WORD(f_name){\
+ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_W, (int)f_name##_MSB, &uval);\
+ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_W, (int)f_name##_LSB, &uval_lsb);\
+uval = ((uval & 0xFF) << 8) | (uval_lsb & 0xFF);\
+}
+
+static ssize_t lt8491_sysfs_charger_get_attr(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct lt8491_device *ltdev = power_supply_get_drvdata(psy);
+	int ret;
+	unsigned int uval;
+	unsigned int uval_lsb;
+
+	if (strcmp(attr->attr.name, "efficiency") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_EFF_MSB, &uval);
+		if (ret >= 0){
+			ret = lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_EFF_LSB, &uval_lsb);
+			if (ret >= 0){
+				return scnprintf(buf, PAGE_SIZE, "0x%x\n", ((uval & 0xFF) << 8) | (uval_lsb & 0xFF));
+			}
+		}
+	}
+	else if (strcmp(attr->attr.name, "charger_faults") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, (int)F_STAT_CHRG_FAULTS, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "0x%x\n", uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "charge_enable") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_CHRG_EN, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "%d\n", (int)uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "restart") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_RESET_FLAG, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "%d\n", (int)uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "update_telem") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_UPDATE_TELEM_BUSY_RDY, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "%d\n", (int)uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "write_cfg_to_eeprom") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_WRT_TO_BOOT, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "%d\n", (int)uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "cfg_rsense1") == 0){
+		READ_CFG_WORD(F_CFG_RSENSE1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rimon_out") == 0){
+		READ_CFG_WORD(F_CFG_RIMON_OUT)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rsense2") == 0){
+		READ_CFG_WORD(F_CFG_RSENSE2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rdaco") == 0){
+		READ_CFG_WORD(F_CFG_RDACO)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbout1") == 0){
+		READ_CFG_WORD(F_CFG_RFBOUT1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbout2") == 0){
+		READ_CFG_WORD(F_CFG_RFBOUT2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rdaci") == 0){
+		READ_CFG_WORD(F_CFG_RDACI)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbin2") == 0){
+		READ_CFG_WORD(F_CFG_RFBIN2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbin1") == 0){
+		READ_CFG_WORD(F_CFG_RFBIN1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_vs3_25c") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_VS3_25C, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_uv_s0") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_UV_S0, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_s0_uv") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S0_UV, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_s0_s1") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S0_S1, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_s1_s0") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S1_S0, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_use_vs3_in_s2") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_USE_VS3_IN_STAGE2, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_lpmode_en") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_LPMODE_EN, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_ps_s3_en") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_PS_S3_ENABLE, &uval);
+	}
+	else if (strcmp(attr->attr.name, "cfg_user_code") == 0){
+		READ_CFG_WORD(F_CFG_USER_CODE)
+	}
+	else if (strcmp(attr->attr.name, "cfg_init_chrg_en") == 0){
+		ret = lt8491_field_read(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_INIT_CHRG_EN, &uval);
+		if (ret >= 0){
+			return scnprintf(buf, PAGE_SIZE, "%d\n", (int)uval);
+		}
+	}
+	else if (strcmp(attr->attr.name, "enable") == 0){
+		return scnprintf(buf, PAGE_SIZE, "%d\n", (int)ltdev->enabled_state);
+	}
+	else
+		return -EINVAL;
+
+	if (ret < 0)
+		return ret;
+
+	return scnprintf(buf, PAGE_SIZE, "0x%x\n", uval);
+}
+
+#define WRITE_CONF_WORD(f_name){\
+ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_W, (int) f_name##_MSB, (uval & 0xFF00) >> 8);\
+ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_W, (int) f_name##_LSB, (uval & 0xFF));\
+}
+
+static ssize_t lt8491_sysfs_charger_set_attr(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf,
+					 size_t count)
+{
+	struct power_supply *psy = dev_get_drvdata(dev);
+	struct lt8491_device *ltdev = power_supply_get_drvdata(psy);
+	long val;
+	u16 uval;
+	int ret = -EINVAL;
+
+	if (kstrtol(buf, 10, &val) < 0){
+		return -EINVAL;
+	}
+	if (strcmp(attr->attr.name, "charge_enable") == 0){
+		if ((bool)val){
+			ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_CHRG_EN, 0x1);
+		}
+		else {
+			ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_CHRG_EN, 0x0);
+		}
+		if (ret < 0){
+			return ret;
+		}
+		return count;
+	}
+	else if (strcmp(attr->attr.name, "restart") == 0){
+		if ((bool)val){
+			if (lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_CHRG_EN, 0x0) >= 0){
+				ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_RESTART_CHIP, 0x99);
+			}
+		}
+		if (ret < 0){
+			return ret;
+		}
+		return count;
+	}
+	else if (strcmp(attr->attr.name, "update_telem") == 0){
+		if ((bool)val){
+			ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_UPDATE_TELEM, 0xAA);
+			if (ret < 0){
+				return ret;
+			}
+		}
+		return count;
+	}
+	else if (strcmp(attr->attr.name, "enable") == 0){
+		if ((bool)val){
+			lt8491_set_enable_gpio(ltdev, 1);
+			msleep(10);
+			if (lt8491_hw_init(ltdev) < 0){
+				return -ENODEV;
+			}
+		}
+		else {
+			lt8491_set_enable_gpio(ltdev, 0);
+		}
+		return count;
+	}
+	if (lt8491_system_is_busy(ltdev)){
+		return -EBUSY;
+	}
+	if (lt8491_charge_is_enabled(ltdev)){
+		dev_err(dev, "Charger enable must be disabled to write to this property\n");
+		return -EPERM;
+	}
+	if (kstrtou16(buf, 10, &uval) < 0){
+		return -EINVAL;
+	}
+	if (strcmp(attr->attr.name, "write_cfg_to_eeprom") == 0){
+		if (val == 1){
+			ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_EE_WRT_EN, 0xCC);
+			if (ret == 0  && lt8491_system_is_busy(ltdev) == false) {
+				ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_WRT_TO_BOOT, 0x30);
+				if (ret != -EINVAL){
+				    ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_EE_WRT_EN, 0x00);
+				}
+            }
+		}
+	}
+	else if (strcmp(attr->attr.name, "cfg_rsense1") == 0){
+		WRITE_CONF_WORD(F_CFG_RSENSE1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rimon_out") == 0){
+		WRITE_CONF_WORD(F_CFG_RIMON_OUT)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rsense2") == 0){
+		WRITE_CONF_WORD(F_CFG_RSENSE2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rdaco") == 0){
+		WRITE_CONF_WORD(F_CFG_RDACO)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbout1") == 0){
+		WRITE_CONF_WORD(F_CFG_RFBOUT1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbout2") == 0){
+		WRITE_CONF_WORD(F_CFG_RFBOUT2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rdaci") == 0){
+		WRITE_CONF_WORD(F_CFG_RDACI)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbin2") == 0){
+		WRITE_CONF_WORD(F_CFG_RFBIN2)
+	}
+	else if (strcmp(attr->attr.name, "cfg_rfbin1") == 0){
+		WRITE_CONF_WORD(F_CFG_RFBIN1)
+	}
+	else if (strcmp(attr->attr.name, "cfg_vs3_25c") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_VS3_25C, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_uv_s0") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_UV_S0, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_s0_uv") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S0_UV, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_s0_s1") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S0_S1, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_s1_s0") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_S1_S0, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_use_vs3_in_s2") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_USE_VS3_IN_STAGE2, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_lpmode_en") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_LPMODE_EN, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_misc_ps_s3_en") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_PS_S3_ENABLE, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_tbat_min") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_TBAT_MIN, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_tbat_max") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_TBAT_MAX, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_rstrt_in_donea") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_RSTRT_IN_DONEA, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_terminate") == 0){
+		ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_TERMINATE, (uval & 0xFF));
+	}
+	else if (strcmp(attr->attr.name, "cfg_user_code") == 0){
+		WRITE_CONF_WORD(F_CFG_USER_CODE)
+	}
+	else if (strcmp(attr->attr.name, "cfg_init_chrg_en") == 0){
+		if ((bool)val){
+			ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_INIT_CHRG_EN, 0x1);
+		}
+		else {
+			ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_B, (int)F_CFG_INIT_CHRG_EN, 0x0);
+		}
+	}
+	else
+		return -EINVAL;
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR(efficiency, 0444, lt8491_sysfs_charger_get_attr, NULL);
+static DEVICE_ATTR(charger_faults, 0444, lt8491_sysfs_charger_get_attr, NULL);
+static DEVICE_ATTR(charge_enable, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(restart, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(update_telem, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(write_cfg_to_eeprom, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rsense1, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rimon_out, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rsense2, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rdaco, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rfbout1, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rfbout2, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rdaci, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rfbin1, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rfbin2, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_vs3_25c, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_uv_s0, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_s0_uv, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_s0_s1, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_s1_s0, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_misc_use_vs3_in_s2, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_misc_lpmode_en, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_misc_ps_s3_en, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_user_code, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_init_chrg_en, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_tbat_min, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_tbat_max, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_rstrt_in_donea, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(cfg_terminate, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+static DEVICE_ATTR(enable, 0644, lt8491_sysfs_charger_get_attr, lt8491_sysfs_charger_set_attr);
+
+static struct attribute *lt8491_charger_sysfs_attrs[] = {
+	&dev_attr_efficiency.attr,
+	&dev_attr_charger_faults.attr,
+	&dev_attr_charge_enable.attr,
+	&dev_attr_restart.attr,
+	&dev_attr_update_telem.attr,
+	&dev_attr_write_cfg_to_eeprom.attr,
+	&dev_attr_cfg_rsense1.attr,
+	&dev_attr_cfg_rimon_out.attr,
+	&dev_attr_cfg_rsense2.attr,
+	&dev_attr_cfg_rdaco.attr,
+	&dev_attr_cfg_rfbout1.attr,
+	&dev_attr_cfg_rfbout2.attr,
+	&dev_attr_cfg_rdaci.attr,
+	&dev_attr_cfg_rfbin1.attr,
+	&dev_attr_cfg_rfbin2.attr,
+	&dev_attr_cfg_user_code.attr,
+	&dev_attr_cfg_vs3_25c.attr,
+	&dev_attr_cfg_uv_s0.attr,
+	&dev_attr_cfg_s0_uv.attr,
+	&dev_attr_cfg_s0_s1.attr,
+	&dev_attr_cfg_s1_s0.attr,
+	&dev_attr_cfg_misc_use_vs3_in_s2.attr,
+	&dev_attr_cfg_misc_lpmode_en.attr,
+	&dev_attr_cfg_misc_ps_s3_en.attr,
+	&dev_attr_cfg_init_chrg_en.attr,
+	&dev_attr_cfg_tbat_min.attr,
+	&dev_attr_cfg_tbat_max.attr,
+	&dev_attr_cfg_rstrt_in_donea.attr,
+	&dev_attr_cfg_terminate.attr,
+	&dev_attr_enable.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(lt8491_charger_sysfs);
+
+// ---------------------------------------------------------
+
+static int lt8491_battery_get_property(struct power_supply *psy,
+					     enum power_supply_property psp,
+					     union power_supply_propval *val)
+{
+	struct lt8491_device *ltdev = power_supply_get_drvdata(psy);
+	unsigned int uval;
+	unsigned int uval_lsb;
+	switch (psp) {
+	case POWER_SUPPLY_PROP_PRESENT: 
+		if (lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, (int)F_STAT_BAT_DISCON_FLT, &uval) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)uval;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW: // TELE_VBAT, value in microvolts
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VBAT_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_VBAT_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)(((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 10000;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW: // TELE_IOUT, value in microamps
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_IOUT_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_IOUT_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)(((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 1000;
+		break;
+	case POWER_SUPPLY_PROP_ENERGY_NOW: // TELE_POUT, value in microwatts
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_POUT_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_POUT_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)(((uval & 0xFF) << 8) | (uval_lsb & 0xFF)) * 10000;
+		break;
+	case POWER_SUPPLY_PROP_TEMP: // tenths of a degree celcius
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_TBAT_MSB, &uval) < 0){
+			return -EINVAL;
+		}
+		if (lt8491_field_read(ltdev, LT8491_TELE_REGMAP, (int)F_TELE_TBAT_LSB, &uval_lsb) < 0){
+			return -EINVAL;
+		}
+		val->intval = (int)(((uval & 0xFF) << 8) | (uval_lsb & 0xFF));
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property lt8491_power_supply_batt_props[] = {
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_ENERGY_NOW,
+	POWER_SUPPLY_PROP_TEMP,
+};
+
+static const struct power_supply_desc lt8491_power_supply_battery_desc = {
+	.name = "battery",
+	.type = POWER_SUPPLY_TYPE_BATTERY,
+	.properties = lt8491_power_supply_batt_props,
+	.num_properties = ARRAY_SIZE(lt8491_power_supply_batt_props),
+	.get_property = lt8491_battery_get_property,
+};
+
+// static DEVICE_ATTR(attrName, Privs, read_function, write_function);
+// 
+// static struct attribute *lt8491_battery_sysfs_attrs[] = {
+// 	&dev_attr_attrName.attr,
+// 	NULL,
+// };
+// ATTRIBUTE_GROUPS(lt8491_battery_sysfs);
+
+// ---------------------------------
+
+static int lt8491_power_supply_init(struct lt8491_device *ltdev)
+{
+	struct power_supply_config psy_chg_cfg = { .drv_data = ltdev, };
+	struct power_supply_config psy_batt_cfg = { .drv_data = ltdev, };
+
+	psy_chg_cfg.attr_grp = lt8491_charger_sysfs_groups;
+	psy_chg_cfg.supplied_to = lt8491_charger_supplied_to;
+	psy_chg_cfg.num_supplicants = ARRAY_SIZE(lt8491_charger_supplied_to);
+
+	ltdev->charger = devm_power_supply_register(ltdev->dev,
+						 &lt8491_power_supply_charger_desc,
+						 &psy_chg_cfg);
+
+	if (PTR_ERR_OR_ZERO(ltdev->charger) < 0){
+		return PTR_ERR_OR_ZERO(ltdev->charger);
+	};
+
+
+	//psy_cfg.attr_grp = lt8491_battery_sysfs;
+
+	ltdev->battery = devm_power_supply_register(ltdev->dev,
+						 &lt8491_power_supply_battery_desc,
+						 &psy_batt_cfg);
+
+	return PTR_ERR_OR_ZERO(ltdev->battery);
+}
+
+static int lt8491_hw_init(struct lt8491_device *ltdev)
+{
+	// read boot_success
+	unsigned int uval;
+	int ret, i;
+
+	if (lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, F_STAT_BOOT_SUCCESS, &uval) < 0){
+		ret = -ENODEV; 
+		goto init_done;
+	}
+	if (uval == 0){
+		if (lt8491_field_write(ltdev, LT8491_STAT_REGMAP_B, F_STAT_BOOT_SUCCESS, 0x5A) < 0){
+			ret = -ENODEV;
+			goto init_done;
+		}
+	}
+	for (i=0; i < 10; i++){
+		if(lt8491_field_read(ltdev, LT8491_STAT_REGMAP_B, F_STAT_SYSTEM_BUSY, &uval) < 0){
+			ret = -ENODEV;
+			break;
+		}
+		if (uval == 0){
+			ret = 0;
+			break;
+		}
+	}
+init_done:
+	return ret;
+}
+
+static int lt8491_parse_dt(struct lt8491_device *ltdev)
+{
+	enum gpiod_flags gflags;
+ 	if (of_property_read_bool(ltdev->dev->of_node, "enable-at-boot"))
+		ltdev->enabled_state = true;
+	
+	if (ltdev->enabled_state)
+		gflags = GPIOD_OUT_HIGH;
+	else
+		gflags = GPIOD_OUT_LOW;
+
+	ltdev->enable = devm_gpiod_get_optional(ltdev->dev, "chip-enable", gflags);
+	if (IS_ERR(ltdev->enable)){
+		return PTR_ERR(ltdev->enable);
+	}
+	if (ltdev->enable){
+		gpiod_direction_output(ltdev->enable, (int)ltdev->enabled_state);
+	}
+	return 0;
+}
+
+
+static int lt8491_conf_from_dt(struct lt8491_device *ltdev)
+{
+	u32 tmp_word;
+	long of_word;
+	const char *of_val;
+	int idx, ret = 0;
+	unsigned int num_regs;
+	unsigned int setup_reg, reg_val;
+	dev_dbg(ltdev->dev, "setting vals from devicetree");
+	if (lt8491_field_read(ltdev, LT8491_CONF_REGMAP_W, F_CFG_USER_CODE_LSB, &tmp_word) < 0){
+		ret = -EINVAL;
+	}
+	else {
+		dev_dbg(ltdev->dev, "got usercode_lsb %d", tmp_word);
+		if ((of_property_read_string(ltdev->dev->of_node, "unique-conf-id", &of_val) == 0))
+		{
+			dev_dbg(ltdev->dev, "got unique-conf %s", of_val);
+			if (kstrtol(of_val, 10, &of_word) < 0){
+				return -EINVAL;
+			}
+			if (tmp_word != of_word){
+				dev_dbg(ltdev->dev, "usercode and uniqued conf id dont match, writing to eeprom");
+				ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_CHRG_EN, 0x0);
+				ret = lt8491_field_write(ltdev, LT8491_CONF_REGMAP_W, (int)F_CFG_USER_CODE_LSB, of_word);
+				msleep(10);
+				dev_dbg(ltdev->dev, "charge_enable off");
+				if (ltdev->dev->of_node){
+					if (of_property_read_u32(ltdev->dev->of_node, "num-setup-regs", &num_regs) == 0){
+						for (idx = 0; idx < num_regs*2;){
+							if (of_property_read_u32_index(ltdev->dev->of_node, "setup-regs", idx, &setup_reg) == 0){
+								if (of_property_read_u32_index(ltdev->dev->of_node, "setup-regs", idx+1, &reg_val) == 0){
+									dev_dbg(ltdev->dev, "of: setting 0x%x to 0x%x", setup_reg, reg_val);
+									i2c_smbus_write_byte_data(ltdev->client, setup_reg, reg_val);
+								}
+							}
+							else {dev_dbg(ltdev->dev, "of: setup-regs failed to read");}
+							idx = idx + 2;
+						}
+					}
+					else {dev_dbg(ltdev->dev, "of: num-setup-regs failed to read");}
+				}
+				else {dev_dbg(ltdev->dev, "No of_node found.");}
+
+				if (ret >= 0){
+					ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_EE_WRT_EN, 0xCC);
+					if (ret == 0  && lt8491_system_is_busy(ltdev) == false) {
+						ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_WRT_TO_BOOT, 0x30);
+						if (ret != -EINVAL){
+							ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_EE_WRT_EN, 0x00);
+						}
+					}
+				}
+				ret = lt8491_field_write(ltdev, LT8491_CTRL_REGMAP, (int)F_CTRL_RESTART_CHIP, 0x99);
+			}
+		}
+	}
+	return ret;
+}
+
+#define INIT_REGMAP_AND_FIELDS(name){ \
+	ltdev->name##_regmap = devm_regmap_init_i2c(client, &lt8491_##name##_regmap_config); \
+	if (IS_ERR(ltdev->name##_regmap)) { \
+		ret = PTR_ERR(ltdev->name##_regmap); \
+		dev_err(&client->dev, \
+			"Failed to allocate name register map: %d\n", ret); \
+		return ret; \
+	} \
+	for (i = 0; i < ARRAY_SIZE(lt8491_##name##_fields); i++) { \
+		const struct reg_field *reg_fields = lt8491_##name##_fields; \
+		ltdev->name##_rmap_fields[i] = devm_regmap_field_alloc(dev, ltdev->name##_regmap, \
+								reg_fields[i]); \
+		if (IS_ERR(ltdev->name##_rmap_fields[i])) { \
+			dev_err(dev, "cannot allocate regmap field\n"); \
+			return PTR_ERR(ltdev->name##_rmap_fields[i]); \
+		} \
+	} \
+}
+static int lt8491_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adapter = client->adapter;
+	struct device *dev = &client->dev;
+	struct lt8491_device *ltdev;
+	int ret;
+	int i;
+	bool enabled_at_boot;
+
+	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "No support for SMBUS_BYTE_DATA\n");
+		return -ENODEV;
+	}
+	ltdev = devm_kzalloc(dev, sizeof(*ltdev), GFP_KERNEL);
+	if (!ltdev)
+		return -ENOMEM;
+	ltdev->client = client;
+	ltdev->dev = dev;
+
+	ltdev->chip = (enum lt8491_chip)id->driver_data;
+
+	INIT_REGMAP_AND_FIELDS(tele)
+	INIT_REGMAP_AND_FIELDS(statb)
+	INIT_REGMAP_AND_FIELDS(statw)
+	INIT_REGMAP_AND_FIELDS(ctrl)
+	INIT_REGMAP_AND_FIELDS(confb)
+	INIT_REGMAP_AND_FIELDS(confw)
+	INIT_REGMAP_AND_FIELDS(conflw)
+	INIT_REGMAP_AND_FIELDS(mfgr)
+	INIT_REGMAP_AND_FIELDS(bootb)
+	INIT_REGMAP_AND_FIELDS(bootw)
+	INIT_REGMAP_AND_FIELDS(bootlw)
+
+	i2c_set_clientdata(client, ltdev);
+
+	// of configuration
+	if (dev->of_node) {
+		lt8491_parse_dt(ltdev);
+	} else {
+		return -ENODEV;
+	}
+	//handle any init writes here
+	enabled_at_boot = ltdev->enabled_state;
+	lt8491_set_enable_gpio(ltdev, 1);
+	msleep(10);
+	ret = lt8491_hw_init(ltdev);
+	if (ret < 0) {
+		dev_err(dev, "Cannot initialize the chip. (%d)\n", ret);
+		return ret;
+	}
+	
+	ret = lt8491_power_supply_init(ltdev);
+	if (ret < 0) {
+		dev_err(dev, "Failed to register power supply\n");
+		return ret;
+	}
+	lt8491_conf_from_dt(ltdev);
+
+	if (!enabled_at_boot){
+		lt8491_set_enable_gpio(ltdev, 0);
+	}
+
+	return 0;
+}
+
+static int lt8491_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static const struct of_device_id lt8491_i2c_of_match[] = {
+	{
+		.compatible = "lltc,lt8491",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lt8491_i2c_of_match);
+
+static const struct i2c_device_id lt8491_i2c_id[] = {
+	{ "lt8491", 0, },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lt8491_i2c_id);
+
+
+static struct i2c_driver lt8491_driver = {
+	.driver = {
+		.name	= "LT8491-charger",
+		.of_match_table = lt8491_i2c_of_match,
+	},
+	.probe		= lt8491_probe,
+	.remove		= lt8491_remove,
+	.id_table	= lt8491_i2c_id,
+};
+module_i2c_driver(lt8491_driver);
+
+MODULE_AUTHOR("Brenden Tisler, EMAC Inc");
+MODULE_DESCRIPTION("LT8491 Battery Charge Controller IC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/power/supply/lt8491-charger.h b/drivers/power/supply/lt8491-charger.h
new file mode 100644
index 000000000000..1e6569d103a0
--- /dev/null
+++ b/drivers/power/supply/lt8491-charger.h
@@ -0,0 +1,664 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * I2C client/driver for the Linear Technology LT8491
+ * Battery Charger IC
+ *
+ * Copyright (C) 2022 EMAC Inc.
+ * Author: Brenden Tisler
+ */
+
+#include <linux/regmap.h>
+
+#define LT8491_TELE_TBAT			0x00
+#define LT8491_TELE_POUT			0x02
+#define LT8491_TELE_PIN				0x04
+#define LT8491_TELE_EFF				0x06
+#define LT8491_TELE_IOUT			0x08
+#define LT8491_TELE_IIN				0x0A
+#define LT8491_TELE_VBAT			0x0C
+#define LT8491_TELE_VIN				0x0E
+#define LT8491_TELE_VINR			0x10
+#define LT8491_STAT_CHARGER			0x12
+#define LT8491_STAT_SYSTEM			0x13
+#define LT8491_STAT_SUPPLY			0x14
+#define LT8491_STAT_TS0_REMAIN		0x15
+#define LT8491_STAT_TS1_REMAIN		0x16
+#define LT8491_STAT_TS2_REMAIN		0x17
+#define LT8491_STAT_TS3_REMAIN		0x18
+#define LT8491_STAT_CHRG_FAULTS		0x19
+#define LT8491_STAT_VERSION			0x1A
+#define LT8491_STAT_BOOT_CRC		0x1C
+#define LT8491_STAT_CFG_CRC			0x1E
+#define LT8491_CTRL_WRT_TO_BOOT		0x20
+#define LT8491_CTRL_EE_WRT_EN		0x21
+#define LT8491_CTRL_HALT_STARTUP	0x22
+#define LT8491_CTRL_CHRG_EN			0x23
+#define LT8491_CTRL_RESTART_CHIP	0x24
+#define LT8491_CTRL_RESET_FLAG		0x25
+#define LT8491_CTRL_UPDATE_TELEM	0x26
+#define LT8491_CFG_RSENSE1			0x28
+#define LT8491_CFG_RIMON_OUT		0x2A
+#define LT8491_CFG_RSENSE2			0x2C
+#define LT8491_CFG_RDACO			0x2E
+#define LT8491_CFG_RFBOUT1			0x30
+#define LT8491_CFG_RFBOUT2			0x32
+#define LT8491_CFG_RDACI			0x34
+#define LT8491_CFG_RFBIN2			0x36
+#define LT8491_CFG_RFBIN1			0x38
+#define LT8491_CFG_INIT_CHRG_EN		0x3A
+#define LT8491_CFG_VS3_25C			0x3B
+#define LT8491_CFG_UV_S0			0x3C
+#define LT8491_CFG_S0_UV			0x3D
+#define LT8491_CFG_S0_S1			0x3E
+#define LT8491_CFG_S1_S0			0x3F
+#define LT8491_CFG_TBAT_MIN			0x40
+#define LT8491_CFG_TBAT_MAX			0x41
+#define LT8491_CFG_TMR_S0			0x42
+#define LT8491_CFG_TMR_S1			0x43
+#define LT8491_CFG_TMR_S2			0x44
+#define LT8491_CFG_TMR_S3			0x45
+#define LT8491_CFG_RSTRT_IN_FLT		0x46
+#define LT8491_CFG_RSTRT_IN_DONEA	0x47
+#define LT8491_CFG_RSTRT_IN_DONEB	0x48
+#define LT8491_CFG_RSTRT_IN_S3		0x49
+#define LT8491_CFG_TERMINATE		0x4A
+#define LT8491_CFG_SCAN_RATE_LP		0x4B
+#define LT8491_CFG_SCAN_RATE		0x4C
+#define LT8491_CFG_CHRG_MISC		0x4D
+#define LT8491_CFG_TC3				0x4E
+#define LT8491_CFG_TC2				0x52
+#define LT8491_CFG_TC1				0x56
+#define LT8491_CFG_USER_CODE		0x5A
+#define LT8491_MFR_DATA1			0x5C
+#define LT8491_MFR_DATA2			0x5E
+#define LT8491_MFR_DATA3			0x60
+#define LT8491_BOOT_RSENSE1			0x88
+#define LT8491_BOOT_RIMON_OUT		0x8A
+#define LT8491_BOOT_RSENSE2			0x8C
+#define LT8491_BOOT_RDACO			0x8E
+#define LT8491_BOOT_RFBOUT1			0x90
+#define LT8491_BOOT_RFBOUT2			0x92
+#define LT8491_BOOT_RDACI			0x94
+#define LT8491_BOOT_RFBIN2			0x96
+#define LT8491_BOOT_RFBIN1			0x98
+#define LT8491_BOOT_INIT_CHRG_EN	0x9A
+#define LT8491_BOOT_VS3_25C			0x9B
+#define LT8491_BOOT_UV_S0			0x9C
+#define LT8491_BOOT_S0_UV			0x9D
+#define LT8491_BOOT_S0_S1			0x9E
+#define LT8491_BOOT_S1_S0			0x9F
+#define LT8491_BOOT_TBAT_MIN		0xA0
+#define LT8491_BOOT_TBAT_MAX		0xA1
+#define LT8491_BOOT_TMR_S0			0xA2
+#define LT8491_BOOT_TMR_S1			0xA3
+#define LT8491_BOOT_TMR_S2			0xA4
+#define LT8491_BOOT_TMR_S3			0xA5
+#define LT8491_BOOT_RSTRT_IN_FLT	0xA6
+#define LT8491_BOOT_RSTRT_IN_DONEA	0xA7
+#define LT8491_BOOT_RSTRT_IN_DONEB	0xA8
+#define LT8491_BOOT_RSTRT_IN_S3		0xA9
+#define LT8491_BOOT_TERMINATE		0xAA
+#define LT8491_BOOT_SCAN_RATE_LP	0xAB
+#define LT8491_BOOT_SCAN_RATE		0xAC
+#define LT8491_BOOT_CHRG_MISC		0xAD
+#define LT8491_BOOT_TC3				0xAE
+#define LT8491_BOOT_TC2				0xB2
+#define LT8491_BOOT_TC1				0xB6
+#define LT8491_BOOT_USER_CODE		0xBA
+#define LT8491_BOOT_CRC				0xBC
+
+#define LT8491_MANUFACTURER		"Linear Technology"
+
+
+
+enum lt8491_chip {
+	LT8491,
+};
+
+static const char *const lt8491_chip_name[] = {
+	"lt8491",
+};
+
+
+enum lt8491_regmaps {
+	LT8491_TELE_REGMAP = 0,
+	LT8491_STAT_REGMAP_B,
+	LT8491_STAT_REGMAP_W,
+	LT8491_CTRL_REGMAP,
+	LT8491_CONF_REGMAP_B,
+	LT8491_CONF_REGMAP_W,
+	LT8491_CONF_REGMAP_LW,
+	LT8491_MFGR_REGMAP,
+	LT8491_BOOT_REGMAP_B,
+	LT8491_BOOT_REGMAP_W,
+	LT8491_BOOT_REGMAP_LW,
+	LT8491_MAX_REGMAP,
+};
+
+
+
+static bool lt8491_is_volatile_reg(struct device *dev, unsigned int reg);
+
+enum lt8491_tele_fields {
+	F_TELE_TBAT_LSB,
+	F_TELE_TBAT_MSB,
+	F_TELE_POUT_LSB,
+	F_TELE_POUT_MSB,
+	F_TELE_PIN_LSB,
+	F_TELE_PIN_MSB,
+	F_TELE_EFF_LSB,
+	F_TELE_EFF_MSB,
+	F_TELE_IOUT_LSB,
+	F_TELE_IOUT_MSB,
+	F_TELE_IIN_LSB,
+	F_TELE_IIN_MSB,
+	F_TELE_VBAT_LSB,
+	F_TELE_VBAT_MSB,
+	F_TELE_VIN_LSB,
+	F_TELE_VIN_MSB,
+	F_TELE_VINR_LSB,
+	F_TELE_VINR_MSB,
+	F_TELE_MAX
+};
+static const struct regmap_config lt8491_tele_regmap_config = {
+	// LT8491_TELE_REGMAP
+	.name = "telemetry_data",
+	.reg_bits = 8,
+	.val_bits = 8,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+
+static const struct reg_field lt8491_tele_fields[] = 
+{ // LT8491_TELE_REGMAP
+	[F_TELE_TBAT_LSB]					= REG_FIELD(LT8491_TELE_TBAT, 0, 8),
+	[F_TELE_TBAT_MSB]					= REG_FIELD(LT8491_TELE_TBAT+1, 0, 8),
+	[F_TELE_POUT_LSB]					= REG_FIELD(LT8491_TELE_POUT, 0, 8),
+	[F_TELE_POUT_MSB]					= REG_FIELD(LT8491_TELE_POUT+1, 0, 8),
+	[F_TELE_PIN_LSB]					= REG_FIELD(LT8491_TELE_PIN, 0, 8),
+	[F_TELE_PIN_MSB]					= REG_FIELD(LT8491_TELE_PIN+1, 0, 8),
+	[F_TELE_EFF_LSB]					= REG_FIELD(LT8491_TELE_EFF, 0, 8),
+	[F_TELE_EFF_MSB]					= REG_FIELD(LT8491_TELE_EFF+1, 0, 8),
+	[F_TELE_IOUT_LSB]					= REG_FIELD(LT8491_TELE_IOUT, 0, 8),
+	[F_TELE_IOUT_MSB]					= REG_FIELD(LT8491_TELE_IOUT+1, 0, 8),
+	[F_TELE_IIN_LSB]					= REG_FIELD(LT8491_TELE_IIN, 0, 8),
+	[F_TELE_IIN_MSB]					= REG_FIELD(LT8491_TELE_IIN+1, 0, 8),
+	[F_TELE_VBAT_LSB]					= REG_FIELD(LT8491_TELE_VBAT, 0, 8),
+	[F_TELE_VBAT_MSB]					= REG_FIELD(LT8491_TELE_VBAT+1, 0, 8),
+	[F_TELE_VIN_LSB]					= REG_FIELD(LT8491_TELE_VIN, 0, 8),
+	[F_TELE_VIN_MSB]					= REG_FIELD(LT8491_TELE_VIN+1, 0, 8),
+	[F_TELE_VINR_LSB]					= REG_FIELD(LT8491_TELE_VINR, 0, 8),
+	[F_TELE_VINR_MSB]					= REG_FIELD(LT8491_TELE_VINR+1, 0, 8),
+};
+
+enum lt8491_statb_fields {
+	F_STAT_CHRG_FAULT, F_STAT_TELEM_ACTIVE,F_STAT_CHRG_STAGE, 
+		F_STAT_CHARGING, F_STAT_GT_C10, F_STAT_CHRG_LOGIC_ON,
+	F_STAT_BOOT_SUCCESS, F_STAT_CRC_ERR_FACTORY, F_STAT_CRCR_ERR_BOOT, 
+		F_STAT_SWENO, F_STAT_SYSTEM_BUSY,
+	F_STAT_VIN_UVLO, F_STAT_PS_OR_SOLAR, F_STAT_SOLAR_STATE,
+	F_STAT_TS0_REMAIN,
+	F_STAT_TS1_REMAIN,
+	F_STAT_TS2_REMAIN,
+	F_STAT_TS3_REMAIN,
+	F_STAT_CHRG_FAULTS,
+	F_STAT_TS3_EXPIRED_FLT, F_STAT_TS2_EXPIRED_FLT, F_STAT_TS1_EXPIRED_FLT, 
+		F_STAT_TS0_EXPIRED_FLT, F_STAT_BAT_DISCON_FLT, F_STAT_HIGH_TBAT_FLT, 
+		F_STAT_LOW_TBAT_FLT, F_STAT_LOW_VBAT_FLT,
+	F_STAT_VERSION,
+	F_STATB_MAX
+};
+static const struct regmap_config lt8491_statb_regmap_config = {
+	// LT8491_STAT_REGMAP_B
+	.name = "status_reg8",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_statb_fields[] = 
+{ // LT8491_STAT_REGMAP_B
+	[F_STAT_CHRG_FAULT]				= REG_FIELD(LT8491_STAT_CHARGER, 7, 7),
+	[F_STAT_TELEM_ACTIVE]			= REG_FIELD(LT8491_STAT_CHARGER, 6, 6),
+	[F_STAT_CHRG_STAGE]				= REG_FIELD(LT8491_STAT_CHARGER, 3, 5),
+	[F_STAT_CHARGING]				= REG_FIELD(LT8491_STAT_CHARGER, 2, 2),
+	[F_STAT_GT_C10]					= REG_FIELD(LT8491_STAT_CHARGER, 1, 1),
+	[F_STAT_CHRG_LOGIC_ON]			= REG_FIELD(LT8491_STAT_CHARGER, 0, 0),
+
+	[F_STAT_BOOT_SUCCESS]			= REG_FIELD(LT8491_STAT_SYSTEM, 5, 5),
+	[F_STAT_CRC_ERR_FACTORY]		= REG_FIELD(LT8491_STAT_SYSTEM, 4, 4),
+	[F_STAT_CRCR_ERR_BOOT]			= REG_FIELD(LT8491_STAT_SYSTEM, 3, 3),
+	[F_STAT_SWENO]					= REG_FIELD(LT8491_STAT_SYSTEM, 2, 2),
+	[F_STAT_SYSTEM_BUSY]			= REG_FIELD(LT8491_STAT_SYSTEM, 0, 1),
+	
+	[F_STAT_VIN_UVLO]				= REG_FIELD(LT8491_STAT_SUPPLY, 4, 4),
+	[F_STAT_PS_OR_SOLAR]			= REG_FIELD(LT8491_STAT_SUPPLY, 3, 3),
+	[F_STAT_SOLAR_STATE]			= REG_FIELD(LT8491_STAT_SUPPLY, 0, 2),
+	
+	[F_STAT_TS0_REMAIN] 			= REG_FIELD(LT8491_STAT_TS0_REMAIN, 0, 7),
+	[F_STAT_TS1_REMAIN] 			= REG_FIELD(LT8491_STAT_TS1_REMAIN, 0, 7),
+	[F_STAT_TS2_REMAIN] 			= REG_FIELD(LT8491_STAT_TS2_REMAIN, 0, 7),
+	[F_STAT_TS3_REMAIN] 			= REG_FIELD(LT8491_STAT_TS3_REMAIN, 0, 7),
+	
+	[F_STAT_CHRG_FAULTS]			= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 0, 7),
+	[F_STAT_TS3_EXPIRED_FLT]		= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 7, 7),
+	[F_STAT_TS2_EXPIRED_FLT]		= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 6, 6),
+	[F_STAT_TS1_EXPIRED_FLT]		= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 5, 5),
+	[F_STAT_TS0_EXPIRED_FLT]		= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 4, 4),
+	[F_STAT_BAT_DISCON_FLT]			= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 3, 3),
+	[F_STAT_HIGH_TBAT_FLT]			= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 2, 2),
+	[F_STAT_LOW_TBAT_FLT]			= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 1, 1),
+	[F_STAT_LOW_VBAT_FLT]			= REG_FIELD(LT8491_STAT_CHRG_FAULTS, 0, 0),
+	
+	[F_STAT_VERSION]				= REG_FIELD(LT8491_STAT_VERSION, 0, 7),
+};
+
+enum lt8491_statw_fields {
+	F_STAT_BOOT_CRC_MSB,
+	F_STAT_BOOT_CRC_LSB,
+	F_STAT_CFG_CRC_MSB,
+	F_STAT_CFG_CRC_LSB,
+	F_STATW_MAX
+};
+static const struct regmap_config lt8491_statw_regmap_config = {
+	// LT8491_STAT_REGMAP_W
+	.name = "status_reg16",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_statw_fields[] = 
+{ // LT8491_STAT_REGMAP_W
+	[F_STAT_BOOT_CRC_LSB]				= REG_FIELD(LT8491_STAT_BOOT_CRC, 0, 8),
+	[F_STAT_BOOT_CRC_MSB]				= REG_FIELD(LT8491_STAT_BOOT_CRC+1, 0, 8),
+	[F_STAT_CFG_CRC_LSB]				= REG_FIELD(LT8491_STAT_CFG_CRC, 0, 8),
+	[F_STAT_CFG_CRC_MSB]				= REG_FIELD(LT8491_STAT_CFG_CRC+1, 0, 8),
+};
+
+enum lt8491_ctrl_fields {
+	F_CTRL_WRT_TO_BOOT, F_CTRL_WRITE_FAIL, 
+		F_CTRL_WRITE_SUCCESS, F_CTRL_BUSY_RDY,
+	F_CTRL_EE_WRT_EN,
+	F_CTRL_HALT_STARTUP,
+	F_CTRL_CHRG_EN,
+	F_CTRL_RESTART_CHIP,
+	F_CTRL_RESET_FLAG,
+	F_CTRL_UPDATE_TELEM, F_CTRL_UPDATE_TELEM_BUSY_RDY,
+	F_CTRL_MAX,
+};
+static const struct regmap_config lt8491_ctrl_regmap_config = {
+	// LT8491_CTRL_REGMAP
+	.name = "control",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = false,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_ctrl_fields[] = 
+{	// LT8491_CTRL_REGMAP 
+	[F_CTRL_WRT_TO_BOOT] 			= REG_FIELD(LT8491_CTRL_WRT_TO_BOOT, 0, 7), 
+	[F_CTRL_WRITE_FAIL] 			= REG_FIELD(LT8491_CTRL_WRT_TO_BOOT, 2, 2), 
+	[F_CTRL_WRITE_SUCCESS] 			= REG_FIELD(LT8491_CTRL_WRT_TO_BOOT, 1, 1), 
+	[F_CTRL_BUSY_RDY] 				= REG_FIELD(LT8491_CTRL_WRT_TO_BOOT, 0, 0), 
+
+	[F_CTRL_EE_WRT_EN] 				= REG_FIELD(LT8491_CTRL_EE_WRT_EN, 0, 7),
+	[F_CTRL_HALT_STARTUP] 			= REG_FIELD(LT8491_CTRL_HALT_STARTUP, 0, 7),
+	[F_CTRL_CHRG_EN] 				= REG_FIELD(LT8491_CTRL_CHRG_EN, 0, 7),
+	[F_CTRL_RESTART_CHIP] 			= REG_FIELD(LT8491_CTRL_RESTART_CHIP, 0, 7),
+	[F_CTRL_RESET_FLAG] 			= REG_FIELD(LT8491_CTRL_RESET_FLAG, 0, 7),
+	
+	[F_CTRL_UPDATE_TELEM] 			= REG_FIELD(LT8491_CTRL_UPDATE_TELEM, 0, 7),
+	[F_CTRL_UPDATE_TELEM_BUSY_RDY] 	= REG_FIELD(LT8491_CTRL_UPDATE_TELEM, 0, 0),
+};
+
+enum lt8491_confb_fields {
+	F_CFG_INIT_CHRG_EN,
+	F_CFG_VS3_25C,
+	F_CFG_UV_S0,
+	F_CFG_S0_UV,
+	F_CFG_S0_S1,
+	F_CFG_S1_S0,
+	F_CFG_TBAT_MIN,
+	F_CFG_TBAT_MAX,
+	F_CFG_TMR_S0,
+	F_CFG_TMR_S1,
+	F_CFG_TMR_S2,
+	F_CFG_TMR_S3,
+	F_CFG_RSTRT_ON_TMR_FLT_HRS, F_CFG_NO_RSTRT_ON_VOLTS, 
+		F_CFG_NO_RSTRT_ON_DISCON_FLT, F_CFG_NO_RSTRT_ON_BATLOW_FLT, 
+		F_CFG_NO_RESUME_ON_TBAT_FLT,
+	F_CFG_RSTRT_IN_DONEA,
+	F_CFG_RSTRT_IN_DONE_ON_VOLTS, F_CFG_RSTRT_IN_DONE_SET_VOLTS,
+	F_CFG_RSTRT_IN_DONE_HRS,
+	F_CFG_RSTRT_S3_C5_VS3,
+	F_CFG_TERMINATE,
+	F_CFG_PS_S2_C10_TERM_EN, F_CFG_SOLAR_S2_C10_TERM_EN,
+		F_CFG_S3_TMR_TERM_EN, F_CFG_S2_TMR_TERM_EN,
+		F_CFG_S1_TMR_TERM_EN, F_CFG_S0_TMR_TERM_EN,
+	F_CFG_SCAN_RATE_LP,
+	F_CFG_SCAN_RATE,
+	F_CFG_USE_VS3_IN_STAGE2, F_CFG_LPMODE_EN, F_CFG_PS_S3_ENABLE, 
+		F_CFG_SOLAR_S3_ENABLE, F_CFG_TC_ENABLE,
+	F_CONFB_MAX
+};
+static const struct regmap_config lt8491_confb_regmap_config = {
+	// LT8491_CONF_REGMAP_B
+	.name = "config_reg8",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_confb_fields[] = 
+{	// LT8491_CONF_REGMAP_B
+	[F_CFG_INIT_CHRG_EN] 			= REG_FIELD(LT8491_CFG_INIT_CHRG_EN, 0, 7),
+	[F_CFG_VS3_25C] 				= REG_FIELD(LT8491_CFG_VS3_25C, 0, 7),
+	[F_CFG_UV_S0] 					= REG_FIELD(LT8491_CFG_UV_S0, 0, 7),
+	[F_CFG_S0_UV] 					= REG_FIELD(LT8491_CFG_S0_UV, 0, 7),
+	[F_CFG_S0_S1] 					= REG_FIELD(LT8491_CFG_S0_S1, 0, 7),
+	[F_CFG_S1_S0] 					= REG_FIELD(LT8491_CFG_S1_S0, 0, 7),
+	[F_CFG_TBAT_MIN] 				= REG_FIELD(LT8491_CFG_TBAT_MIN, 0, 7),
+	[F_CFG_TBAT_MAX] 				= REG_FIELD(LT8491_CFG_TBAT_MAX, 0, 7),
+	[F_CFG_TMR_S0] 					= REG_FIELD(LT8491_CFG_TMR_S0, 0, 7),
+	[F_CFG_TMR_S1] 					= REG_FIELD(LT8491_CFG_TMR_S1, 0, 7),
+	[F_CFG_TMR_S2] 					= REG_FIELD(LT8491_CFG_TMR_S2, 0, 7),
+	[F_CFG_TMR_S3] 					= REG_FIELD(LT8491_CFG_TMR_S3, 0, 7),
+
+	[F_CFG_RSTRT_ON_TMR_FLT_HRS] 	= REG_FIELD(LT8491_CFG_RSTRT_IN_FLT, 4, 7),
+	[F_CFG_NO_RSTRT_ON_VOLTS] 		= REG_FIELD(LT8491_CFG_RSTRT_IN_FLT, 3, 3),
+	[F_CFG_NO_RSTRT_ON_DISCON_FLT] 	= REG_FIELD(LT8491_CFG_RSTRT_IN_FLT, 2, 2),
+	[F_CFG_NO_RSTRT_ON_BATLOW_FLT] 	= REG_FIELD(LT8491_CFG_RSTRT_IN_FLT, 1, 1),
+	[F_CFG_NO_RESUME_ON_TBAT_FLT] 	= REG_FIELD(LT8491_CFG_RSTRT_IN_FLT, 0, 0),
+
+	[F_CFG_RSTRT_IN_DONEA] 			= REG_FIELD(LT8491_CFG_RSTRT_IN_DONEA, 0, 7),
+	[F_CFG_RSTRT_IN_DONE_ON_VOLTS] 	= REG_FIELD(LT8491_CFG_RSTRT_IN_DONEA, 7, 7),
+	[F_CFG_RSTRT_IN_DONE_SET_VOLTS] = REG_FIELD(LT8491_CFG_RSTRT_IN_DONEA, 0, 6),
+
+	[F_CFG_RSTRT_IN_DONE_HRS] 		= REG_FIELD(LT8491_CFG_RSTRT_IN_DONEB, 0, 5),
+	[F_CFG_RSTRT_S3_C5_VS3] 		= REG_FIELD(LT8491_CFG_RSTRT_IN_S3, 0, 0),
+
+	[F_CFG_TERMINATE]		 		= REG_FIELD(LT8491_CFG_TERMINATE, 0, 5),
+	[F_CFG_PS_S2_C10_TERM_EN] 		= REG_FIELD(LT8491_CFG_TERMINATE, 5, 5),
+	[F_CFG_SOLAR_S2_C10_TERM_EN] 	= REG_FIELD(LT8491_CFG_TERMINATE, 4, 4),
+	[F_CFG_S3_TMR_TERM_EN] 			= REG_FIELD(LT8491_CFG_TERMINATE, 3, 3),
+	[F_CFG_S2_TMR_TERM_EN] 			= REG_FIELD(LT8491_CFG_TERMINATE, 2, 2),
+	[F_CFG_S1_TMR_TERM_EN] 			= REG_FIELD(LT8491_CFG_TERMINATE, 1, 1),
+	[F_CFG_S0_TMR_TERM_EN] 			= REG_FIELD(LT8491_CFG_TERMINATE, 0, 0),
+
+	[F_CFG_SCAN_RATE_LP] 			= REG_FIELD(LT8491_CFG_SCAN_RATE_LP, 0, 7),
+	[F_CFG_SCAN_RATE] 				= REG_FIELD(LT8491_CFG_SCAN_RATE, 0, 7),
+	
+	[F_CFG_USE_VS3_IN_STAGE2] 		= REG_FIELD(LT8491_CFG_CHRG_MISC, 4, 4),
+	[F_CFG_LPMODE_EN] 				= REG_FIELD(LT8491_CFG_CHRG_MISC, 3, 3),
+	[F_CFG_PS_S3_ENABLE] 			= REG_FIELD(LT8491_CFG_CHRG_MISC, 2, 2),
+	[F_CFG_SOLAR_S3_ENABLE] 		= REG_FIELD(LT8491_CFG_CHRG_MISC, 1, 1),
+	[F_CFG_TC_ENABLE] 				= REG_FIELD(LT8491_CFG_CHRG_MISC, 0, 0),
+};
+
+enum lt8491_confw_fields {
+	F_CFG_RSENSE1_MSB,
+	F_CFG_RSENSE1_LSB,
+	F_CFG_RIMON_OUT_MSB,
+	F_CFG_RIMON_OUT_LSB,
+	F_CFG_RSENSE2_MSB,
+	F_CFG_RSENSE2_LSB,
+	F_CFG_RDACO_MSB,
+	F_CFG_RDACO_LSB,
+	F_CFG_RFBOUT1_MSB,
+	F_CFG_RFBOUT1_LSB,
+	F_CFG_RFBOUT2_MSB,
+	F_CFG_RFBOUT2_LSB,
+	F_CFG_RDACI_MSB,
+	F_CFG_RDACI_LSB,
+	F_CFG_RFBIN2_MSB,
+	F_CFG_RFBIN2_LSB,
+	F_CFG_RFBIN1_MSB,
+	F_CFG_RFBIN1_LSB,
+	F_CFG_USER_CODE_MSB,
+	F_CFG_USER_CODE_LSB,
+	F_CONFW_MAX,
+};
+static const struct regmap_config lt8491_confw_regmap_config = {
+	// LT8491_CONF_REGMAP_W
+	.name = "config_reg16",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_confw_fields[] = 
+{	// LT8491_CONF_REGMAP_W 
+	[F_CFG_RSENSE1_LSB] 				= REG_FIELD(LT8491_CFG_RSENSE1, 0, 7),
+	[F_CFG_RSENSE1_MSB] 				= REG_FIELD(LT8491_CFG_RSENSE1+1, 0, 7),
+	[F_CFG_RIMON_OUT_LSB] 				= REG_FIELD(LT8491_CFG_RIMON_OUT, 0, 7),
+	[F_CFG_RIMON_OUT_MSB] 				= REG_FIELD(LT8491_CFG_RIMON_OUT+1, 0, 7),
+	[F_CFG_RSENSE2_LSB] 				= REG_FIELD(LT8491_CFG_RSENSE2, 0, 7),
+	[F_CFG_RSENSE2_MSB] 				= REG_FIELD(LT8491_CFG_RSENSE2+1, 0, 7),
+	[F_CFG_RDACO_LSB] 					= REG_FIELD(LT8491_CFG_RDACO, 0, 7),
+	[F_CFG_RDACO_MSB] 					= REG_FIELD(LT8491_CFG_RDACO+1, 0, 7),
+	[F_CFG_RFBOUT1_LSB] 				= REG_FIELD(LT8491_CFG_RFBOUT1, 0, 7),
+	[F_CFG_RFBOUT1_MSB] 				= REG_FIELD(LT8491_CFG_RFBOUT1+1, 0, 7),
+	[F_CFG_RFBOUT2_LSB] 				= REG_FIELD(LT8491_CFG_RFBOUT2, 0, 7),
+	[F_CFG_RFBOUT2_MSB] 				= REG_FIELD(LT8491_CFG_RFBOUT2+1, 0, 7),
+	[F_CFG_RDACI_LSB] 					= REG_FIELD(LT8491_CFG_RDACI, 0, 7),
+	[F_CFG_RDACI_MSB] 					= REG_FIELD(LT8491_CFG_RDACI+1, 0, 7),
+	[F_CFG_RFBIN2_LSB] 					= REG_FIELD(LT8491_CFG_RFBIN2, 0, 7),
+	[F_CFG_RFBIN2_MSB] 					= REG_FIELD(LT8491_CFG_RFBIN2+1, 0, 7),
+	[F_CFG_RFBIN1_LSB] 					= REG_FIELD(LT8491_CFG_RFBIN1, 0, 7),
+	[F_CFG_RFBIN1_MSB] 					= REG_FIELD(LT8491_CFG_RFBIN1+1, 0, 7),
+	[F_CFG_USER_CODE_LSB] 				= REG_FIELD(LT8491_CFG_USER_CODE, 0, 7),
+	[F_CFG_USER_CODE_MSB] 				= REG_FIELD(LT8491_CFG_USER_CODE+1, 0, 7),
+};
+
+enum lt8491_conflw_fields {
+	F_CFG_TC3,
+	F_CFG_TC2,
+	F_CFG_TC1,
+	F_CONFLW_MAX,
+};
+static const struct regmap_config lt8491_conflw_regmap_config = {
+	// LT8491_CONF_REGMAP_LW
+	.name = "config_reg32",
+	.reg_bits = 8,
+	.val_bits = 32,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_conflw_fields[] = 
+{	// LT8491_CONF_REGMAP_LW
+	[F_CFG_TC3] 					= REG_FIELD(LT8491_CFG_TC3, 0, 32),
+	[F_CFG_TC2] 					= REG_FIELD(LT8491_CFG_TC2, 0, 32),
+	[F_CFG_TC1] 					= REG_FIELD(LT8491_CFG_TC1, 0, 32),
+};
+
+enum lt8491_mfgr_fields {
+	F_MFR_DATA1,
+	F_MFR_DATA2,
+	F_MFR_DATA3,
+	F_MFR_MAX,
+};
+static const struct regmap_config lt8491_mfgr_regmap_config = {
+	// LT8491_MFGR_REGMAP
+	.name = "manufacturer_data",
+	.reg_bits = 8,
+	.val_bits = 16,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_mfgr_fields[] = 
+{	// LT8491_MFGR_REGMAP 
+	[F_MFR_DATA1] 					= REG_FIELD(LT8491_MFR_DATA1, 0, 16),
+	[F_MFR_DATA2] 					= REG_FIELD(LT8491_MFR_DATA2, 0, 16),
+	[F_MFR_DATA3] 					= REG_FIELD(LT8491_MFR_DATA3, 0, 16),
+};
+
+enum lt8491_bootb_fields {
+	F_BOOT_INIT_CHRG_EN,
+	F_BOOT_VS3_25C,
+	F_BOOT_UV_S0,
+	F_BOOT_S0_UV,
+	F_BOOT_S0_S1,
+	F_BOOT_S1_S0,
+	F_BOOT_TBAT_MIN,
+	F_BOOT_TBAT_MAX,
+	F_BOOT_TMR_S0,
+	F_BOOT_TMR_S1,
+	F_BOOT_TMR_S2,
+	F_BOOT_TMR_S3,
+	F_BOOT_RSTRT_ON_TMR_FLT_HRS, F_BOOT_NO_RSTRT_ON_VOLTS, 
+		F_BOOT_NO_RSTRT_ON_DISCON_FLT, F_BOOT_NO_RSTRT_ON_BATLOW_FLT, 
+		F_BOOT_NO_RESUME_ON_TBAT_FLT,
+	F_BOOT_RSTRT_IN_DONE_ON_VOLTS, F_BOOT_RSTRT_IN_DONE_SET_VOLTS,
+	F_BOOT_RSTRT_IN_DONE_HRS,
+	F_BOOT_RSTRT_S3_C5_VS3,
+	F_BOOT_PS_S2_C10_TERM_EN, F_BOOT_SOLAR_S2_C10_TERM_EN,
+		F_BOOT_S3_TMR_TERM_EN, F_BOOT_S2_TMR_TERM_EN,
+		F_BOOT_S1_TMR_TERM_EN, F_BOOT_S0_TMR_TERM_EN,
+	F_BOOT_SCAN_RATE_LP,
+	F_BOOT_SCAN_RATE,
+	F_BOOT_USE_VS3_IN_STAGE2, F_BOOT_LPMODE_EN, F_BOOT_PS_S3_ENABLE, 
+		F_BOOT_SOLAR_S3_ENABLE, F_BOOT_TC_ENABLE,
+	F_BOOTB_MAX,
+};
+static const struct regmap_config lt8491_bootb_regmap_config = {
+	// LT8491_BOOT_REGMAP_B
+	.name = "eeprom_reg8",
+	.reg_bits = 8,
+	.val_bits = 8,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_bootb_fields[] = 
+{	// LT8491_BOOT_REGMAP_B
+	[F_BOOT_INIT_CHRG_EN] 			= REG_FIELD(LT8491_BOOT_INIT_CHRG_EN, 0, 7),
+	[F_BOOT_VS3_25C] 				= REG_FIELD(LT8491_BOOT_VS3_25C, 0, 7),
+	[F_BOOT_UV_S0] 					= REG_FIELD(LT8491_BOOT_UV_S0, 0, 7),
+	[F_BOOT_S0_UV] 					= REG_FIELD(LT8491_BOOT_S0_UV, 0, 7),
+	[F_BOOT_S0_S1] 					= REG_FIELD(LT8491_BOOT_S0_S1, 0, 7),
+	[F_BOOT_S1_S0] 					= REG_FIELD(LT8491_BOOT_S1_S0, 0, 7),
+	[F_BOOT_TBAT_MIN] 				= REG_FIELD(LT8491_BOOT_TBAT_MIN, 0, 7),
+	[F_BOOT_TBAT_MAX] 				= REG_FIELD(LT8491_BOOT_TBAT_MAX, 0, 7),
+	[F_BOOT_TMR_S0] 				= REG_FIELD(LT8491_BOOT_TMR_S0, 0, 7),
+	[F_BOOT_TMR_S1] 				= REG_FIELD(LT8491_BOOT_TMR_S1, 0, 7),
+	[F_BOOT_TMR_S2] 				= REG_FIELD(LT8491_BOOT_TMR_S2, 0, 7),
+	[F_BOOT_TMR_S3] 				= REG_FIELD(LT8491_BOOT_TMR_S3, 0, 7),
+
+	[F_BOOT_RSTRT_ON_TMR_FLT_HRS] 	= REG_FIELD(LT8491_BOOT_RSTRT_IN_FLT, 4, 7),
+	[F_BOOT_NO_RSTRT_ON_VOLTS] 		= REG_FIELD(LT8491_BOOT_RSTRT_IN_FLT, 3, 3),
+	[F_BOOT_NO_RSTRT_ON_DISCON_FLT] = REG_FIELD(LT8491_BOOT_RSTRT_IN_FLT, 2, 2),
+	[F_BOOT_NO_RSTRT_ON_BATLOW_FLT] = REG_FIELD(LT8491_BOOT_RSTRT_IN_FLT, 1, 1),
+	[F_BOOT_NO_RESUME_ON_TBAT_FLT] 	= REG_FIELD(LT8491_BOOT_RSTRT_IN_FLT, 0, 0),
+
+	[F_BOOT_RSTRT_IN_DONE_ON_VOLTS] = REG_FIELD(LT8491_BOOT_RSTRT_IN_DONEA, 7, 7),
+	[F_BOOT_RSTRT_IN_DONE_SET_VOLTS]= REG_FIELD(LT8491_BOOT_RSTRT_IN_DONEA, 0, 6),
+
+	[F_BOOT_RSTRT_IN_DONE_HRS] 		= REG_FIELD(LT8491_BOOT_RSTRT_IN_DONEB, 0, 5),
+	[F_BOOT_RSTRT_S3_C5_VS3] 		= REG_FIELD(LT8491_BOOT_RSTRT_IN_S3, 0, 0),
+
+	[F_BOOT_PS_S2_C10_TERM_EN] 		= REG_FIELD(LT8491_BOOT_TERMINATE, 5, 5),
+	[F_BOOT_SOLAR_S2_C10_TERM_EN] 	= REG_FIELD(LT8491_BOOT_TERMINATE, 4, 4),
+	[F_BOOT_S3_TMR_TERM_EN] 		= REG_FIELD(LT8491_BOOT_TERMINATE, 3, 3),
+	[F_BOOT_S2_TMR_TERM_EN] 		= REG_FIELD(LT8491_BOOT_TERMINATE, 2, 2),
+	[F_BOOT_S1_TMR_TERM_EN] 		= REG_FIELD(LT8491_BOOT_TERMINATE, 1, 1),
+	[F_BOOT_S0_TMR_TERM_EN] 		= REG_FIELD(LT8491_BOOT_TERMINATE, 0, 0),
+
+	[F_BOOT_SCAN_RATE_LP] 			= REG_FIELD(LT8491_BOOT_SCAN_RATE_LP, 0, 7),
+	[F_BOOT_SCAN_RATE] 				= REG_FIELD(LT8491_BOOT_SCAN_RATE, 0, 7),
+	
+	[F_BOOT_USE_VS3_IN_STAGE2] 		= REG_FIELD(LT8491_BOOT_CHRG_MISC, 4, 4),
+	[F_BOOT_LPMODE_EN] 				= REG_FIELD(LT8491_BOOT_CHRG_MISC, 3, 3),
+	[F_BOOT_PS_S3_ENABLE] 			= REG_FIELD(LT8491_BOOT_CHRG_MISC, 2, 2),
+	[F_BOOT_SOLAR_S3_ENABLE] 		= REG_FIELD(LT8491_BOOT_CHRG_MISC, 1, 1),
+	[F_BOOT_TC_ENABLE] 				= REG_FIELD(LT8491_BOOT_CHRG_MISC, 0, 0),
+};
+
+enum lt8491_bootw_fields {
+	F_BOOT_RSENSE1,
+	F_BOOT_RIMON_OUT,
+	F_BOOT_RSENSE2,
+	F_BOOT_RDACO,
+	F_BOOT_RFBOUT1,
+	F_BOOT_RFBOUT2,
+	F_BOOT_RDACI,
+	F_BOOT_RFBIN2,
+	F_BOOT_RFBIN1,
+	F_BOOT_USER_CODE,
+	F_BOOT_CRC,
+	F_BOOTW_MAX,
+};
+static const struct regmap_config lt8491_bootw_regmap_config = {
+	// LT8491_BOOT_REGMAP_W
+	.name = "eeprom_reg16",
+	.reg_bits = 8,
+	.val_bits = 16,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_bootw_fields[] = 
+{	// LT8491_BOOT_REGMAP_W 
+	[F_BOOT_RSENSE1] 				= REG_FIELD(LT8491_BOOT_RSENSE1, 0, 15),
+	[F_BOOT_RIMON_OUT] 				= REG_FIELD(LT8491_BOOT_RIMON_OUT, 0, 15),
+	[F_BOOT_RSENSE2] 				= REG_FIELD(LT8491_BOOT_RSENSE2, 0, 15),
+	[F_BOOT_RDACO] 					= REG_FIELD(LT8491_BOOT_RDACO, 0, 15),
+	[F_BOOT_RFBOUT1] 				= REG_FIELD(LT8491_BOOT_RFBOUT1, 0, 15),
+	[F_BOOT_RFBOUT2] 				= REG_FIELD(LT8491_BOOT_RFBOUT2, 0, 15),
+	[F_BOOT_RDACI] 					= REG_FIELD(LT8491_BOOT_RDACI, 0, 15),
+	[F_BOOT_RFBIN2] 				= REG_FIELD(LT8491_BOOT_RFBIN2, 0, 15),
+	[F_BOOT_RFBIN1] 				= REG_FIELD(LT8491_BOOT_RFBIN1, 0, 15),
+	[F_BOOT_USER_CODE] 				= REG_FIELD(LT8491_BOOT_USER_CODE, 0, 15),
+	[F_BOOT_CRC] 					= REG_FIELD(LT8491_BOOT_CRC, 0, 15),
+};
+
+enum lt8491_bootlw_fields {
+	F_BOOT_TC3,
+	F_BOOT_TC2,
+	F_BOOT_TC1,
+	F_BOOTLW_MAX,
+};
+static const struct regmap_config lt8491_bootlw_regmap_config = {
+	// LT8491_BOOT_REGMAP_LW
+	.name = "eeprom_reg32",
+	.reg_bits = 8,
+	.val_bits = 32,
+	.use_single_write = true,
+
+	.cache_type = REGCACHE_NONE,
+
+	.volatile_reg = lt8491_is_volatile_reg,
+};
+static const struct reg_field lt8491_bootlw_fields[] = 
+{	// LT8491_BOOT_REGMAP_LW
+	[F_BOOT_TC3] 					= REG_FIELD(LT8491_BOOT_TC3, 0, 32),
+	[F_BOOT_TC2] 					= REG_FIELD(LT8491_BOOT_TC2, 0, 32),
+	[F_BOOT_TC1] 					= REG_FIELD(LT8491_BOOT_TC1, 0, 32),
+};
