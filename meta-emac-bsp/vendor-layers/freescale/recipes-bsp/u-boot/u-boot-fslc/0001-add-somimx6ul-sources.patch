From d9f7a7dceb48a2a9aa20cdcac3eb2bea9f16395d Mon Sep 17 00:00:00 2001
From: Brenden Tisler <btisler@emacinc.com>
Date: Tue, 5 Sep 2023 12:12:16 -0500
Subject: [PATCH] add somimx6ul sources

Signed-off-by: Brenden Tisler <btisler@emacinc.com>
---
 arch/arm/dts/som-imx6ul.dts          | 287 +++++++++++++++++++++++++++
 board/emac/somimx6ul/Kconfig         |  12 ++
 board/emac/somimx6ul/Makefile        |   9 +
 board/emac/somimx6ul/somimx6ul.c     | 155 +++++++++++++++
 board/emac/somimx6ul/somimx6ul_spl.c | 238 ++++++++++++++++++++++
 configs/somimx6ul_defconfig          |  90 +++++++++
 include/configs/somimx6ul.h          |  57 ++++++
 7 files changed, 848 insertions(+)
 create mode 100644 arch/arm/dts/som-imx6ul.dts
 create mode 100644 board/emac/somimx6ul/Kconfig
 create mode 100644 board/emac/somimx6ul/Makefile
 create mode 100644 board/emac/somimx6ul/somimx6ul.c
 create mode 100644 board/emac/somimx6ul/somimx6ul_spl.c
 create mode 100644 configs/somimx6ul_defconfig
 create mode 100644 include/configs/somimx6ul.h

diff --git a/arch/arm/dts/som-imx6ul.dts b/arch/arm/dts/som-imx6ul.dts
new file mode 100644
index 0000000000..8ed47e9821
--- /dev/null
+++ b/arch/arm/dts/som-imx6ul.dts
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2016 EMAC Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/dts-v1/;
+
+#include "imx6ul.dtsi"
+
+/ {
+	model = "EMAC SOM-i.MX6UL";
+	compatible = "emac,som-imx6ul-150es", "fsl,imx6ul";
+
+	chosen {
+		stdout-path = &uart5;
+	};
+	
+	aliases {
+		spi0 = &ecspi1;
+		spi1 = &ecspi2;
+		spi2 = &ecspi3;
+		spi3 = &ecspi4;
+		spi4 = &qspi;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x80000000 0x8000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_led>;
+
+		stat {
+			label = "status";
+			gpios = <&gpio4 16 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+	};
+
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		reg_sd1_vmmc: sd1_regulator {
+			compatible = "regulator-fixed";
+			regulator-name = "VSD_3V3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+
+		reg_usb_otg_vbus: regulator-usb-otg-vbus {
+			compatible = "regulator-fixed";
+			pinctrl-names = "default";
+			regulator-name = "usb_otg_vbus";
+			regulator-min-microvolt = <5000000>;
+			regulator-max-microvolt = <5000000>;
+			regulator-always-on;
+		};
+	};
+};
+
+&ecspi4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi4>;
+	fsl,spi-num-chipselects = <1>;
+	cs-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	flash: n25q128@0 {
+		compatible = "micron,n25q128a13", "jedec,spi-nor";
+		spi-max-frequency = <40000000>;
+		reg = <0>;
+	};
+};
+
+&fec1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_enet1>;
+	phy-mode = "rmii";
+	phy-handle = <&ethphy0>;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy0: ethernet-phy@1 {
+			reg = <1>;
+		};
+	};
+};
+
+&snvs_poweroff {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	fsl,uart-has-rtscts;
+	status = "okay";
+};
+
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	status = "okay";
+};
+
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	status = "okay";
+};
+
+&uart5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart5>;
+	status = "okay";
+};
+
+&usbotg1 {
+	vbus-supply = <&reg_usb_otg_vbus>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb_otg1_id>;
+	dr_mode = "otg";
+	srp-disable;
+	hnp-disable;
+	adp-disable;
+	status = "okay";
+};
+
+&usbotg2 {
+	dr_mode = "host";
+	disable-over-current;
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc1>;
+	non-removable;
+	no-1-8-v;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	vmmc-supply = <&reg_sd1_vmmc>;
+	no-1-8-v;
+	cd-gpios = <&gpio4 11 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+
+	pinctrl_led: ledgrp {
+		fsl,pins = <
+			MX6UL_PAD_NAND_DQS__GPIO4_IO16		0x1b0b0
+		>;
+	};
+
+	pinctrl_ecspi4: ecspi4grp {
+		fsl,pins = <
+			MX6UL_PAD_ENET2_RX_ER__GPIO2_IO15	0x0b0b0
+			MX6UL_PAD_ENET2_RX_EN__GPIO2_IO10	0x0b0b0
+			MX6UL_PAD_ENET2_TX_DATA0__GPIO2_IO11	0x0b0b0
+			MX6UL_PAD_LCD_DATA04__GPIO3_IO09	0x0b0b0
+			MX6UL_PAD_ENET2_TX_EN__ECSPI4_MOSI	0x0b0b0
+			MX6UL_PAD_ENET2_TX_CLK__ECSPI4_MISO	0x0b0b0
+			MX6UL_PAD_ENET2_TX_DATA1__ECSPI4_SCLK	0x0b0b0
+		>;
+	};
+
+	pinctrl_enet1: enet1grp {
+		fsl,pins = <
+			MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	0x1b0b0
+			MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	0x1b0b0
+			MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	0x1b0b0
+			MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
+			MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
+			MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
+			MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
+			MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001b031
+			MX6UL_PAD_ENET2_RX_DATA0__ENET1_MDIO	0x1b0b0
+			MX6UL_PAD_ENET2_RX_DATA1__ENET1_MDC	0x1b0b0
+		>;
+	};
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO02__I2C1_SCL 0x4001b8b0
+			MX6UL_PAD_GPIO1_IO03__I2C1_SDA 0x4001b8b0
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX6UL_PAD_UART5_TX_DATA__I2C2_SCL 0x4001b8b0
+			MX6UL_PAD_UART5_RX_DATA__I2C2_SDA 0x4001b8b0
+		>;
+	};
+
+	pinctrl_usb_otg1_id: usbotg1idgrp {
+		fsl,pins = <
+			MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID	0x17059
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1
+			MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1b0b1
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
+			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
+			MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS	0x1b0b1
+			MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS	0x1b0b1
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX 0x1b0b1
+			MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX 0x1b0b1
+		>;
+	};
+
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX6UL_PAD_UART4_TX_DATA__UART4_DCE_TX 0x1b0b1
+			MX6UL_PAD_UART4_RX_DATA__UART4_DCE_RX 0x1b0b1
+		>;
+	};
+
+	pinctrl_uart5: uart5grp {
+		fsl,pins = <
+			MX6UL_PAD_UART5_TX_DATA__UART5_DCE_TX 0x1b0b1
+			MX6UL_PAD_UART5_RX_DATA__UART5_DCE_RX 0x1b0b1
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX6UL_PAD_SD1_CMD__USDHC1_CMD     	0x17059
+			MX6UL_PAD_SD1_CLK__USDHC1_CLK     	0x10059
+			MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 	0x17059
+			MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 	0x17059
+			MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 	0x17059
+			MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 	0x17059
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x17059
+			MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x17059
+			MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059
+			MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059
+			MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059
+			MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
+			MX6UL_PAD_NAND_WP_B__GPIO4_IO11     0x170b0
+		>;
+	};
+};
diff --git a/board/emac/somimx6ul/Kconfig b/board/emac/somimx6ul/Kconfig
new file mode 100644
index 0000000000..de50c25a61
--- /dev/null
+++ b/board/emac/somimx6ul/Kconfig
@@ -0,0 +1,12 @@
+if TARGET_SOMIMX6UL
+
+config SYS_BOARD
+       default "somimx6ul"
+
+config SYS_VENDOR
+       default "emac"
+
+config SYS_CONFIG_NAME
+       default "somimx6ul"
+
+endif
diff --git a/board/emac/somimx6ul/Makefile b/board/emac/somimx6ul/Makefile
new file mode 100644
index 0000000000..596019c98c
--- /dev/null
+++ b/board/emac/somimx6ul/Makefile
@@ -0,0 +1,9 @@
+# (C) Copyright 2015 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := somimx6ul.o
+ifdef CONFIG_SPL_BUILD
+obj-y += somimx6ul_spl.o
+endif
diff --git a/board/emac/somimx6ul/somimx6ul.c b/board/emac/somimx6ul/somimx6ul.c
new file mode 100644
index 0000000000..18c74452b5
--- /dev/null
+++ b/board/emac/somimx6ul/somimx6ul.c
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2016 EMAC, Inc.
+ *
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/io.h>
+#include <common.h>
+#include <i2c.h>
+#include <linux/sizes.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <usb.h>
+#include <micrel.h>
+#include <led.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define MEM_STRIDE 0x4000000
+static u32 get_ram_size_stride_test(u32 *base, u32 maxsize)
+{
+        volatile u32 *addr;
+        u32          save[64];
+        u32          cnt;
+        u32          size;
+        int          i = 0;
+
+        /* First save the data */
+        for (cnt = 0; cnt < maxsize; cnt += MEM_STRIDE) {
+                addr = (volatile u32 *)((u32)base + cnt);       /* pointer arith! */
+                sync ();
+                save[i++] = *addr;
+                sync ();
+        }
+
+        /* First write a signature */
+        * (volatile u32 *)base = 0x12345678;
+        for (size = MEM_STRIDE; size < maxsize; size += MEM_STRIDE) {
+                * (volatile u32 *)((u32)base + size) = size;
+                sync ();
+                if (* (volatile u32 *)((u32)base) == size) {	/* We reached the overlapping address */
+                        break;
+                }
+        }
+
+        /* Restore the data */
+        for (cnt = (maxsize - MEM_STRIDE); i > 0; cnt -= MEM_STRIDE) {
+                addr = (volatile u32 *)((u32)base + cnt);       /* pointer arith! */
+                sync ();
+                *addr = save[i--];
+                sync ();
+        }
+
+        return (size);
+}
+
+int dram_init(void)
+{
+	u32 max_size = imx_ddr_size();
+
+	gd->ram_size = get_ram_size_stride_test((u32 *) PHYS_SDRAM,
+						(u32)max_size);
+
+	return 0;
+}
+
+#ifdef CONFIG_FEC_MXC
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int ret;
+
+	if (fec_id == 0) {
+		/*
+		 * Use 50M anatop loopback REF_CLK1 for ENET1,
+		 * clear gpr1[13], set gpr1[17].
+		 */
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC1_MASK,
+				IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);
+	} else {
+		/*
+		 * Use 50M anatop loopback REF_CLK2 for ENET2,
+		 * clear gpr1[14], set gpr1[18].
+		 */
+		clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC2_MASK,
+				IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);
+	}
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_50MHZ);
+	if (ret)
+		return ret;
+
+	enable_enet_clk(1);
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x16, 0x202);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: EMAC SOM-i.MX6UL\n");
+
+	return 0;
+}
diff --git a/board/emac/somimx6ul/somimx6ul_spl.c b/board/emac/somimx6ul/somimx6ul_spl.c
new file mode 100644
index 0000000000..dac538e358
--- /dev/null
+++ b/board/emac/somimx6ul/somimx6ul_spl.c
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0+
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/arch/mx6ul_pins.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <fsl_esdhc_imx.h>
+#include <linux/sizes.h>
+#include <mmc.h>
+#include <spl.h>
+#include <hang.h>
+
+#include <asm/arch/mx6-ddr.h>
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+static struct mx6ul_iomux_grp_regs mx6_grp_ioregs = {
+	.grp_addds = 0x00000030,
+	.grp_ddrmode_ctl = 0x00020000,
+	.grp_b0ds = 0x00000030,
+	.grp_ctlds = 0x00000030,
+	.grp_b1ds = 0x00000030,
+	.grp_ddrpke = 0x00000000,
+	.grp_ddrmode = 0x00020000,
+	.grp_ddr_type = 0x00080000,
+};
+
+static struct mx6ul_iomux_ddr_regs mx6_ddr_ioregs = {
+	.dram_dqm0 = 0x00000030,
+	.dram_dqm1 = 0x00000030,
+	.dram_ras = 0x00000030,
+	.dram_cas = 0x00000030,
+	.dram_odt0 = 0x00000000,
+	.dram_odt1 = 0x00000000,
+	.dram_sdba2 = 0x00000000,
+	.dram_sdclk_0 = 0x00000030,
+	.dram_sdqs0 = 0x00003030,
+	.dram_sdqs1 = 0x00003030,
+	.dram_reset = 0x00000030,
+};
+
+static struct mx6_mmdc_calibration mx6_mmcd_calib = {
+	.p0_mpwldectrl0 = 0x00000000,
+	.p0_mpdgctrl0 = 0x20000000,
+	.p0_mprddlctl = 0x4040484f,
+	.p0_mpwrdlctl = 0x40405247,
+	.mpzqlp2ctl = 0x1b4700c7,
+};
+
+static struct mx6_ddr_sysinfo ddr_sysinfo = {
+	.dsize		= 0,
+	.cs1_mirror	= 0,
+	.cs_density	= 20,
+	.ncs		= 1,
+	.bi_on		= 1,
+	.rtt_nom	= 1,
+	.rtt_wr		= 0,
+	.ralat		= 5,
+	.walat		= 2,
+	.mif3_mode	= 3,
+	.rst_to_cke	= 0x10,
+	.sde_to_rst	= 0,
+	.ddr_type	= DDR_TYPE_LPDDR2,
+	.refsel = 0,
+	.refr = 1,
+};
+
+static struct mx6_lpddr2_cfg mem_ddr = {
+	.mem_speed = 800,
+	.density = 4,
+	.width = 16,
+	.banks = 8,
+	.trcd_lp = 1500,
+	.trppb_lp = 1500,
+	.trpab_lp = 2000,
+	.trasmin = 4250,
+};
+
+static void ccgr_init(void)
+{
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel(0xFFFFFFFF, &ccm->CCGR0);
+	writel(0xFFFFFFFF, &ccm->CCGR1);
+	writel(0xFFFFFFFF, &ccm->CCGR2);
+	writel(0xFFFFFFFF, &ccm->CCGR3);
+	writel(0xFFFFFFFF, &ccm->CCGR4);
+	writel(0xFFFFFFFF, &ccm->CCGR5);
+	writel(0xFFFFFFFF, &ccm->CCGR6);
+	writel(0xFFFFFFFF, &ccm->CCGR7);
+}
+
+static void imx6ul_spl_dram_cfg_size(u32 ram_size)
+{
+	if (ram_size == SZ_512M) {
+		mem_ddr.rowaddr = 14;
+		mem_ddr.coladdr = 11;
+	}
+	else {
+		mem_ddr.rowaddr = 13;
+		mem_ddr.coladdr = 10;
+	}
+
+	mx6ul_dram_iocfg(mem_ddr.width, &mx6_ddr_ioregs, &mx6_grp_ioregs);
+	mx6_dram_cfg(&ddr_sysinfo, &mx6_mmcd_calib, &mem_ddr);
+}
+
+static void imx6ul_spl_dram_cfg(void)
+{
+	ulong ram_size_test, ram_size = 0;
+
+	for (ram_size = SZ_512M; ram_size >= SZ_128M; ram_size >>= 1) {
+		imx6ul_spl_dram_cfg_size(ram_size);
+		ram_size_test = get_ram_size((long int *)PHYS_SDRAM, ram_size);
+
+		if (ram_size_test == ram_size)
+			break;
+	}
+
+	if (ram_size < SZ_128M) {
+		puts("ERROR: DRAM size detection failed\n");
+		hang();
+	}
+}
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	IOMUX_PADS(PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+};
+
+static struct fsl_esdhc_cfg emmc_cfg = {
+	.esdhc_base = USDHC1_BASE_ADDR,
+	.max_bus_width = 4,
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	 return (mmc_get_op_cond(mmc, true) < 0) ? 0 : 1; /* eMMC/uSDHC1 has no CD GPIO */
+}
+
+static int mmc_init_spl(struct bd_info *bis)
+{	
+	/*
+	 * Following map is done:
+	 * (U-Boot device node)    (Physical Port)
+	 * mmc0                    SOM eMMC
+	 */
+	
+	SETUP_IOMUX_PADS(usdhc1_pads);
+	emmc_cfg.sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	gd->arch.sdhc_clk = emmc_cfg.sdhc_clk;
+
+	return fsl_esdhc_initialize(bis, &emmc_cfg);
+}
+
+int board_mmc_init(struct bd_info *bis)
+{
+	if (IS_ENABLED(CONFIG_SPL_BUILD))
+		return mmc_init_spl(bis);
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart5_pads[] = {
+	IOMUX_PADS(PAD_UART5_TX_DATA__UART5_DCE_TX | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_UART5_RX_DATA__UART5_DCE_RX | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+static void setup_iomux_uart(void)
+{
+	SETUP_IOMUX_PADS(uart5_pads);
+}
+
+static iomux_v3_cfg_t const ecspi4_pads[] = {
+	IOMUX_PADS(PAD_ENET2_TX_EN__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET2_TX_DATA1__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET2_TX_CLK__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET2_RX_ER__GPIO2_IO15 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static void setup_iomux_spi(void)
+{
+	SETUP_IOMUX_PADS(ecspi4_pads);
+	enable_spi_clk(1, 3);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 3 && cs == 0) ? (IMX_GPIO_NR(2, 15)) : -1;
+}
+
+void board_init_f(ulong dummy)
+{
+	arch_cpu_init();
+	ccgr_init();
+
+	/* setup GP timer */
+	timer_init();
+
+	setup_iomux_uart();
+	setup_iomux_spi();
+		
+	/* UART clocks enabled and gd valid - init serial console */
+	preloader_console_init();
+	
+	/* DDR initialization */
+	imx6ul_spl_dram_cfg();
+	
+	/* Clear the BSS. */
+	memset(__bss_start, 0, __bss_end - __bss_start);
+	
+	/* load/boot image from boot device */
+	board_init_r(NULL, 0);
+}
+
+void reset_cpu(ulong addr)
+{
+}
diff --git a/include/configs/somimx6ul.h b/include/configs/somimx6ul.h
new file mode 100644
index 0000000000..c76c914711
--- /dev/null
+++ b/include/configs/somimx6ul.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 EMAC, Inc.
+ *
+ * Configuration settings for the SOM-IMX6
+ *
+ * based on mx6ul_14x14_lpddr2_arm2.h 
+ * Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __SOM_IMX6UL_CONFIG_H
+#define __SOM_IMX6UL_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include <linux/stringify.h>
+#include "mx6_common.h"
+#include <asm/mach-imx/gpio.h>
+
+/* SPL options */
+#include "imx6_spl.h"
+
+#define CONFIG_MXC_UART_BASE		UART5_BASE
+
+/* MMC Configs */
+#ifdef CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	USDHC2_BASE_ADDR
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"bootargs=console=ttymxc4,115200 " \
+	"root=/dev/mmcblk0p1 " \
+	"rootfstype=ext4 rootwait rw\0" \
+
+#define PHYS_SDRAM					MMDC0_ARB_BASE_ADDR
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+/* SPI Flash Configs */
+#if defined(CONFIG_SPL_BUILD)
+#undef CONFIG_DM_SPI
+#undef CONFIG_DM_SPI_FLASH
+#endif
+
+/* USB Configs */
+#ifdef CONFIG_CMD_USB
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#endif
+
+#ifdef CONFIG_CMD_NET
+#define CONFIG_FEC_ENET_DEV		0
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#endif
+
+#endif
\ No newline at end of file
-- 
2.34.1

