From f6e15b94fe1568d75a5b022bbf861a45d3c742a0 Mon Sep 17 00:00:00 2001
From: Brenden Tisler <btisler@emacinc.com>
Date: Mon, 24 Jul 2023 18:14:36 -0500
Subject: [PATCH] Add som-5728m board files

Signed-off-by: Brenden Tisler <btisler@emacinc.com>
---
 arch/arm/dts/Makefile                 |   1 +
 arch/arm/dts/emac-som-5728m-350es.dts | 253 ++++++++
 arch/arm/dts/emac-som-5728m.dtsi      | 616 ++++++++++++++++++++
 arch/arm/mach-omap2/omap5/Kconfig     |  11 +
 board/emacinc/common/Kconfig          |  45 ++
 board/emacinc/common/Makefile         |   4 +
 board/emacinc/common/board_detect.c   | 804 ++++++++++++++++++++++++++
 board/emacinc/common/board_detect.h   | 471 +++++++++++++++
 board/emacinc/som-5728m/Kconfig       |  14 +
 board/emacinc/som-5728m/MAINTAINERS   |   8 +
 board/emacinc/som-5728m/Makefile      |   6 +
 board/emacinc/som-5728m/board.c       | 672 +++++++++++++++++++++
 board/emacinc/som-5728m/mux_data.h    | 367 ++++++++++++
 include/configs/emac-som-5728m.h      |  65 +++
 14 files changed, 3337 insertions(+)
 create mode 100644 arch/arm/dts/emac-som-5728m-350es.dts
 create mode 100644 arch/arm/dts/emac-som-5728m.dtsi
 create mode 100644 board/emacinc/common/Kconfig
 create mode 100644 board/emacinc/common/Makefile
 create mode 100644 board/emacinc/common/board_detect.c
 create mode 100644 board/emacinc/common/board_detect.h
 create mode 100644 board/emacinc/som-5728m/Kconfig
 create mode 100644 board/emacinc/som-5728m/MAINTAINERS
 create mode 100644 board/emacinc/som-5728m/Makefile
 create mode 100644 board/emacinc/som-5728m/board.c
 create mode 100644 board/emacinc/som-5728m/mux_data.h
 create mode 100644 include/configs/emac-som-5728m.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 3ecde2d1cc..d75564e14e 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -475,6 +475,7 @@ dtb-$(CONFIG_TARGET_AM57XX_EVM) += am57xx-beagle-x15.dtb \
 	am574x-idk.dtb \
 	am572x-idk.dtb	\
 	am571x-idk.dtb
+dtb-$(CONFIG_TARGET_EMAC_SOM_5728M) += emac-som-5728m-350es.dtb
 dtb-$(CONFIG_TARGET_STV0991) += stv0991.dtb
 
 dtb-$(CONFIG_ARCH_LS1021A) += ls1021a-qds-duart.dtb \
diff --git a/arch/arm/dts/emac-som-5728m-350es.dts b/arch/arm/dts/emac-som-5728m-350es.dts
new file mode 100644
index 0000000000..e096ab7b60
--- /dev/null
+++ b/arch/arm/dts/emac-som-5728m-350es.dts
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "emac-som-5728m.dtsi"
+
+/ {
+	model = "EMAC Inc. SoM-5728M w/ 350ES";
+	compatible = "emac,som-5728m-350es", "emac,som-5728m", "ti,am5728", "ti,dra742", "ti,dra74", "ti,dra7";
+
+	aliases {
+		com-a = &uart3;
+		com-b = &uart5;
+		com-c = &uart6;
+		com-d = &uart7;
+		display0 = &lvds_panel;
+		display1 = &hdmi;
+	};
+
+	wlan_en_reg: wlan-en-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "wlan-en-regulator";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vdd_3v3_reg>;
+		gpio = <&gpio8 2 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <100000>;
+      	enable-active-high;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		tlv320_mclk: tlv320_mclk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <12000000>;
+			clock-output-names = "mclk";
+		};
+	};
+
+	
+	beeper: beeper {
+		compatible = "gpio-beeper";
+		gpios = <&gpio8 12 GPIO_ACTIVE_HIGH>;
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&ecap0 0 50000 0>;
+		power-supply = <&bl_pwr>;
+		brightness-levels = <0 10 20 30 40 50 60 70 80 90 100>;
+		default-brightness-level = <9>;
+	};
+	lvds_panel: display {
+		compatible = "innolux,at070tn92", "simple-panel";
+		backlight = <&backlight>;
+		power-supply = <&vdd_3v3_reg>;
+		ddc-i2c-bus = <&i2c5>;
+		enable-gpios = <&gpio3 4 GPIO_ACTIVE_HIGH>;
+
+		port {
+			lcd_in: endpoint {
+				remote-endpoint = <&lvds_out>;
+			};
+		};
+	};
+	hdmi0_conn: connector {
+		compatible = "hdmi-connector";
+		label = "hdmi";
+		status = "okay";
+		type = "a";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&tpd12s015_out>;
+			};
+		};
+	};
+	sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "tlv320aic32x4";
+		simple-audio-card,bitclock-master = <&codec_master>;
+		simple-audio-card,frame-master = <&codec_master>;
+		simple-audio-card,bitclock-inversion;
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"Headphone Jack", "HPL",
+			"Headphone Jack", "HPR",
+			"IN1_L", "Microphone Jack",
+			"IN1_R", "Microphone Jack",
+			"Microphone Jack", "Mic Bias";
+
+		cpu_master: simple-audio-card,cpu {
+			sound-dai = <&mcasp8>;
+		};
+
+		codec_master: simple-audio-card,codec {
+			sound-dai = <&codec>;
+			clocks = <&tlv320_mclk>;
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+};
+
+// SD Card
+&mmc1 {
+    status = "okay";
+};
+
+// Enable SATA
+&sata_phy {
+	status = "okay";
+};
+&sata {
+	status = "okay";
+};
+
+// usb3.x interface
+&usb1 { 
+	status = "okay";
+};
+&usb2_phy1 {
+	status = "okay";
+};
+
+// usb2.x interface
+&usb2 { 
+	status = "okay";
+};
+&usb2_phy2 {
+	status = "okay";
+};
+
+&mac{
+	status = "okay";
+};
+
+&davinci_mdio {
+    status = "okay";
+};
+
+&cpsw_emac0 {
+    status = "okay";
+};
+
+
+// Display info
+&lvds_out {
+	remote-endpoint = <&lcd_in>;
+	status = "okay";
+};
+&touch {
+	status = "okay";
+};
+&ecap0 {
+	status = "okay";
+};
+&epwmss0 {
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+};
+&tpd12s015_out {
+	remote-endpoint = <&hdmi_connector_in>;
+};
+
+// Sound
+&mcasp8 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+	codec: tlv320aic32x4@18{
+		#sound-dai-cells = <0>;
+		compatible = "ti,tlv320aic32x4";
+		reg = <0x18>;
+		clocks = <&tlv320_mclk>;
+		clock-names = "mclk";
+		iov-supply = <&vdd_3v3_reg>;
+		ldoin-supply = <&vdd_3v3_reg>;
+		input-use = <1 1 0 0 0 0>;
+		cmode = <0x11 0>;
+		status = "okay";
+	};	
+};
+
+// Wifi
+&mmc4 {
+    /* disable MMC4 as SDIO is not supported in U-Boot */
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <0>;
+	wlcore: wlcore@2 {
+		compatible = "ti,wl1835";
+		reg = <0x2>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <10 IRQ_TYPE_LEVEL_HIGH>;
+	};
+};
+
+
+// uarts
+&uart5 {
+	status = "okay";
+	// DCD, DTR, DSR, and RI pings invalid
+	// Pins DTR and RI do not have gpio muxings, instead provide uart 8
+};
+
+&uart6 {
+	status = "okay";
+};
+
+&uart7 {
+	status = "okay";
+};
+
+/*
+ * Can
+ */
+&dcan1 {
+	/* disable DCAN1 as CAN is not supported in U-Boot */
+    status = "disabled";
+};
+
+&dcan2 {
+	/* disable DCAN2 as CAN is not supported in U-Boot */
+    status = "disabled";
+};
+
+&pcie1_rc {
+	gpios = <&gpio7 15 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+
+
+
diff --git a/arch/arm/dts/emac-som-5728m.dtsi b/arch/arm/dts/emac-som-5728m.dtsi
new file mode 100644
index 0000000000..d074b368d6
--- /dev/null
+++ b/arch/arm/dts/emac-som-5728m.dtsi
@@ -0,0 +1,616 @@
+/*
+ * Copyright (C) 2014-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "dra74x.dtsi"
+#include "am57xx-commercial-grade.dtsi"
+
+#include "dra74x-mmc-iodelay.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/net/qca-ar803x.h>
+
+/ {
+	model = "EMAC Inc. SoM-5728M";
+	compatible = "emac,som-5728m", "ti,dra742", "ti,dra74", "ti,dra7";
+
+	aliases {
+		rtc0 = &rtc_rx8803;
+		rtc1 = &tps659038_rtc;
+		rtc2 = &rtc;
+        mmcblk0 = &mmc1;
+        mmcblk1 = &mmc2;
+		spi1 = &mcspi3;
+		spi2 = &mcspi4;
+	};
+
+	chosen {
+		stdout-path = &uart3;
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x40000000>; /* 1GB configuration */
+	};
+
+	vmain: fixedregulator-vmain {
+		compatible = "regulator-fixed";
+		regulator-name = "VMAIN";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	bl_pwr: backlight-pwr-en {
+		compatible = "regulator-fixed";
+		regulator-name = "LVDS ABL EN";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		vin-supply = <&vdd_3v3_reg>;
+		gpio = <&gpio4 31 GPIO_ACTIVE_LOW>;
+		startup-delay-us = <1000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led0 {
+			label = "status";
+			gpios = <&gpio3 0 GPIO_ACTIVE_LOW>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	tpd12s015_enc: encoder {
+		compatible = "ti,tpd12s015";
+		status = "okay";
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				tpd12s015_in: endpoint {
+					remote-endpoint = <&hdmi_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+
+				tpd12s015_out: endpoint {
+					remote-endpoint = <0>;
+				};
+			};
+		};
+	};
+};
+
+&cpu0 {
+	vdd-supply = <&vdd_mpu_reg>;
+	voltage-tolerance = <1>;
+};
+
+&cpu_trips {
+	cpu_alert1: cpu_alert1 {
+		temperature = <50000>; /* millicelsius */
+		hysteresis = <2000>; /* millicelsius */
+		type = "active";
+	};
+};
+
+/*
+ * i2c
+ */
+&i2c1 {
+	status = "okay";
+	clock-frequency = <400000>;
+        // pmic
+	tps659038: tps659038@58 {
+		compatible = "ti,tps659038";
+		reg = <0x58>;
+		interrupt-parent = <&gpio4>;
+		interrupts = <29 IRQ_TYPE_LEVEL_LOW>;
+		#interrupt-cells = <2>;
+		interrupt-controller;
+
+		ti,palmas-override-powerhold;
+		ti,system-power-controller;
+
+		tps659038_pmic {
+			compatible = "ti,tps659038-pmic";
+			smps12-in-supply = <&vmain>;
+			smps3-in-supply = <&vmain>;
+			smps45-in-supply = <&vmain>;
+			smps6-in-supply = <&vmain>;
+			smps7-in-supply = <&vmain>;
+			smps8-in-supply = <&vmain>;
+			smps9-in-supply = <&vmain>;
+			ldo1-in-supply = <&vmain>;
+			ldo2-in-supply = <&vmain>;
+			ldo3-in-supply = <&vmain>;
+			ldo4-in-supply = <&vmain>;
+			ldo9-in-supply = <&vmain>;
+			ldoln-in-supply = <&vmain>;
+			ldousb-in-supply = <&vmain>;
+			ldortc-in-supply = <&vmain>;
+
+			regulators {
+				vdd_mpu_reg: smps12 {
+					regulator-name = "smps12";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				vdd_ddr_reg: smps3 {
+					/* VDD_DDR */
+					regulator-name = "smps3";
+					regulator-min-microvolt = <1350000>;
+					regulator-max-microvolt = <1350000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				vdd_dspeve_reg: smps45 {
+					/* VDD_DSPEVE */
+					regulator-name = "smps45";
+					regulator-min-microvolt = < 850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				vdd_gpu_reg: smps6 {
+					/* VDD_GPU */
+					regulator-name = "smps6";
+					regulator-min-microvolt = <850000>;
+					regulator-max-microvolt = <1250000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				vdd_core_reg: smps7 {
+					/* VDD_CORE */
+					regulator-name = "smps7";
+					regulator-min-microvolt = <850000>;
+					regulator-max-microvolt = <1150000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				vdd_iva_reg: smps8 {
+					/* VDD_IVA */
+					regulator-name = "smps8";
+					//regulator-min-microvolt = <1800000>;
+					//regulator-max-microvolt = <1800000>;
+					//regulator-always-on;
+					//regulator-boot-on;
+				};
+
+				vdd_3v3_reg: smps9 {
+					/* VDD_3V3 */
+					regulator-name = "smps9";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo1_3v3_sd_reg: ldo1 {
+					/* VDD_SD / VDDSHV8  */
+					regulator-name = "ldo1";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-boot-on;
+					regulator-always-on;
+				};
+
+				ldo2_1v8_reg: ldo2 {
+					/* VDD_SHV5 */
+					regulator-name = "ldo2";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo3_1v8_phy_reg: ldo3 {
+					/* VDDA_1V8_PHYA */
+					regulator-name = "ldo3";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo4_1v8_phy_reg: ldo4 {
+					/* VDDA_1V8_PHYB */
+					regulator-name = "ldo4";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldo9_rtc_reg: ldo9 {
+					/* VDD_RTC */
+					regulator-name = "ldo9";
+					regulator-min-microvolt = <840000>;
+					regulator-max-microvolt = <1160000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldoln_1v8_pll_reg: ldoln {
+					/* VDDA_1V8_PLL */
+					regulator-name = "ldoln";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				ldousb_3v3_reg: ldousb {
+					/* VDDA_3V_USB: VDDA_USBHS33 */
+					regulator-name = "ldousb";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <3300000>;
+					regulator-boot-on;
+				};
+				
+				ldortc_1v8_reg: ldortc {
+					/* VDDA_RTC  */
+					regulator-name = "ldortc";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+					regulator-always-on;
+					regulator-boot-on;
+				};
+
+				/* unused */
+				regen1: regen1 {
+					/* VDD_3V3_ON */
+					regulator-name = "regen1";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+				/* unused */
+				regen2: regen2 {
+					/* Needed for PMIC internal resource */
+					regulator-name = "regen2";
+					regulator-boot-on;
+					regulator-always-on;
+				};
+			};
+		};
+
+		tps659038_rtc: tps659038_rtc {
+			compatible = "ti,palmas-rtc";
+			interrupt-parent = <&tps659038>;
+			interrupts = <8 IRQ_TYPE_EDGE_FALLING>;
+			wakeup-source;
+		};
+
+		tps659038_pwr_button: tps659038_pwr_button {
+			compatible = "ti,palmas-pwrbutton";
+			interrupt-parent = <&tps659038>;
+			interrupts = <1 IRQ_TYPE_EDGE_FALLING>;
+			wakeup-source;
+			ti,palmas-long-press-seconds = <12>;
+		};
+        
+	};
+	
+	rtc_rx8803: rtc@32 {
+		status = "okay";
+		compatible = "epson,rv8803";
+		reg = <0x32>;
+	};
+
+	/* STMPE811 touch screen controller */
+	stmpe811@41 {
+		compatible = "st,stmpe811";
+		reg = <0x41>;
+		interrupt-parent = <&gpio6>;
+		interrupts = <16 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-controller;
+		id = <0>;
+		blocks = <0x5>;
+		irq-trigger = <0x1>;
+		st,mod-12b = <1>; /* 12-bit ADC */
+		st,ref-sel = <0>; /* internal ADC reference */
+		st,adc-freq = <1>; /* 3.25 MHz ADC clock speed */
+		st,sample-time = <4>; /* ADC converstion time: 80 clocks */
+
+		stmpe_adc {
+			compatible = "st,stmpe-adc";
+			/* forbid to use ADC channels 3-0 (touch) */
+			st,norequest-mask = <0x0F>;
+		};
+
+		touch: stmpe_touchscreen {
+			status = "disabled";
+			compatible = "st,stmpe-ts";
+			/* 8 sample average control */
+			st,ave-ctrl = <3>;
+			/* 7 length fractional part in z */
+			st,fraction-z = <7>;
+			/*
+			 * 50 mA typical 80 mA max touchscreen drivers
+			 * current limit value
+			 */
+			st,i-drive = <1>;
+			/* 1 ms panel driver settling time */
+			st,settling = <3>;
+			/* 5 ms touch detect interrupt delay */
+			st,touch-det-delay = <5>;
+		};
+	};
+};
+
+/*
+ * SPI interfaces
+*/
+
+&qspi {
+	status = "okay";
+	spi-max-frequency = <76800000>;
+	m25p80@0 {
+		compatible = "w25q128", "jedec,spi-nor";
+		spi-max-frequency = <76800000>;
+		reg = <0>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <1>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+	};
+};
+
+&mcspi3 {
+	status = "disabled";
+	/* CS0 - native (vout1_clk) 
+	 * CS1 - native (vout1_fld) 
+	 * CS2 - native (vout1_d0) 
+	 */
+	cs-gpios = <&gpio4 19>,<&gpio4 21>,<&gpio8 0>;
+	num-cs = <3>;
+};
+
+&mcspi4 {
+	status = "disabled";
+	/* CS0 - native (vin2a_d1) 
+	 * CS1 - native (gpmc_a12) 
+	 * CS2 - nc
+	 * CS3 - native (gpmc_a14) 
+	 */
+	cs-gpios = <&gpio4 2>,<&gpio2 2>,<0>,<&gpio2 4>;
+	num-cs = <4>;
+
+	no-device@2 {/* Do Not Use */};
+};
+
+&mmc1 {
+    status = "disabled";
+    bus-width = <4>;
+    vmmc-supply = <&vdd_3v3_reg>;
+    vqmmc-supply = <&ldo1_3v3_sd_reg>;
+    max-frequency = <48000000>;
+    no-1-8-v;
+    
+    pinctrl-names = "default", "hs";
+	pinctrl-0 = <&mmc1_pins_default>;
+	pinctrl-1 = <&mmc1_pins_hs>;
+};
+
+&mmc2 {
+    status = "okay";
+    vmmc-supply = <&vdd_3v3_reg>;
+    vqmmc-supply = <&vdd_3v3_reg>;
+    bus-width = <8>;
+    non-removable;
+    max-frequency = <96000000>;
+	no-1-8-v;
+    
+    pinctrl-names = "default", "hs";
+	pinctrl-0 = <&mmc2_pins_default>;
+	pinctrl-1 = <&mmc2_pins_hs>;
+};
+
+&mmc4 {
+    status = "disabled";
+    bus-width = <4>;
+    vmmc-supply = <&vdd_3v3_reg>;
+    vqmmc-supply = <&ldo1_3v3_sd_reg>;
+    max-frequency = <48000000>;
+    no-1-8-v;
+
+    pinctrl-names = "default", "hs";
+	pinctrl-0 = <&mmc4_pins_default>;
+	pinctrl-1 = <&mmc4_pins_hs>;
+};
+
+// usb3.x interface
+&usb1 { 
+	dr_mode = "host";
+};
+
+// usb2.x interface
+&usb2 { 
+	dr_mode = "host";
+};
+
+&davinci_mdio {
+	reset-gpios = <&gpio4 25 GPIO_ACTIVE_LOW>;
+	reset-delay-us = <2>;
+
+	phy0: ethernet-phy@1 {
+		reg = <4>;
+		eee-broken-100tx;
+		eee-broken-1000t;
+	};
+};
+
+&mac {
+	slaves = <1>;
+	status = "okay";
+};
+
+&cpsw_emac0 {
+	phy-handle = <&phy0>;
+	phy-mode = "rgmii";
+};
+
+&usb2_phy1 {
+	phy-supply = <&ldousb_3v3_reg>;
+};
+
+&usb2_phy2 {
+	phy-supply = <&ldousb_3v3_reg>;
+};
+
+&dss {
+	status = "okay";
+	vdda_video-supply = <&ldoln_1v8_pll_reg>;
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@2 {
+			reg = <2>;
+			lvds_out: endpoint {
+				data-lines = <18>;
+				status = "disabled";
+			};
+		};
+	};
+};
+
+&hdmi {
+	status = "disabled";
+	vdda-supply = <&ldo4_1v8_phy_reg>;
+
+	port {
+		hdmi_out: endpoint {
+			remote-endpoint = <&tpd12s015_in>;
+		};
+	};
+};
+
+
+&dra7_pmx_core {
+	dcan1_pins_default: dcan1_pins_default {  
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x37d4, PIN_INPUT | MUX_MODE15) 	/* (Errata i893) dcan1_rx.dcan1_rx */
+			DRA7XX_CORE_IOPAD(0x37d0, PIN_OUTPUT | MUX_MODE0) 	/* dcan1_tx.dcan1_tx */
+		>;
+	};
+
+	dcan2_pins_default: dcan2_pins_default {
+		pinctrl-single,pins = <
+			DRA7XX_CORE_IOPAD(0x368c, PIN_INPUT | MUX_MODE15) 	/* (Errata i893) gpio6_15.dcan2_rx */
+			DRA7XX_CORE_IOPAD(0x3688, PIN_OUTPUT | MUX_MODE2) 	/* gpio6_14.dcan2_tx */
+		>;
+	};
+};
+
+/*
+ * Can
+ */
+&dcan1 {
+    status = "disabled";
+    pinctrl-names = "default";
+    pinctrl-0 = <&dcan1_pins_default>;
+};
+
+&dcan2 {
+    status = "disabled";
+    pinctrl-names = "default";
+    pinctrl-0 = <&dcan2_pins_default>;
+};
+
+/*
+ * UART
+ */
+
+&uart1 {
+	status = "disabled";
+};
+
+&uart2 {
+	status = "disabled";
+};
+
+// console
+&uart3 {
+	status = "okay";
+	interrupts-extended = <&crossbar_mpu GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>, <&dra7_pmx_core 0x3f8>;
+};
+
+&mcasp5 {
+    #sound-dai-cells = <0>;
+    assigned-clocks = <&mcasp5_ahclkx_mux>;
+    assigned-clock-parents = <&sys_clkin2>;
+    op-mode = <0>;	
+    tdm-slots = <2>;
+    serial-dir = < 1 2 0 0 >;
+    tx-num-evt = <32>;
+    rx-num-evt = <32>;
+};
+
+&mcasp8 {
+    #sound-dai-cells = <0>;
+    assigned-clocks = <&mcasp8_ahclkx_mux>;
+    assigned-clock-parents = <&sys_clkin2>;
+    op-mode = <0>;	
+    tdm-slots = <2>;
+    serial-dir = < 1 2 0 0 >;
+    tx-num-evt = <32>;
+    rx-num-evt = <32>;
+};
+
+&epwmss0 {
+	eqep0: counter@180 {
+		compatible = "ti,dra746-eqep", 
+				 "ti,am3352-eqep";
+		reg = <0x180 0x80>;
+		clocks = <&l4_root_clk_div>;
+		clock-names = "sysclkout";
+		interrupts = <210>;
+		status = "disabled";
+	};
+};
+
+&epwmss1 {
+	eqep1: counter@180 {
+		compatible = "ti,dra746-eqep", 
+				 "ti,am3352-eqep";
+		reg = <0x180 0x80>;
+		clocks = <&l4_root_clk_div>;
+		clock-names = "sysclkout";
+		interrupts = <211>;
+		status = "disabled";
+	};
+};
+
+&epwmss2 {
+	eqep2: counter@180 {
+		compatible = "ti,dra746-eqep", 
+				 "ti,am3352-eqep";
+		reg = <0x180 0x80>;
+		clocks = <&l4_root_clk_div>;
+		clock-names = "sysclkout";
+		interrupts = <212>;
+		status = "disabled";
+	};
+};
+
+
diff --git a/arch/arm/mach-omap2/omap5/Kconfig b/arch/arm/mach-omap2/omap5/Kconfig
index 0787d192b6..7014d536e7 100644
--- a/arch/arm/mach-omap2/omap5/Kconfig
+++ b/arch/arm/mach-omap2/omap5/Kconfig
@@ -47,6 +47,16 @@ config TARGET_AM57XX_EVM
 	imply SPL_THERMAL
 	imply TI_DRA7_THERMAL
 
+config TARGET_EMAC_SOM_5728M
+	bool "EMACINC SoM-5728M"
+	select BOARD_LATE_INIT
+	select CMD_DDR3
+	select DRA7XX
+	imply DM_THERMAL
+	imply SCSI
+	imply SPL_THERMAL
+	imply TI_DRA7_THERMAL
+
 endchoice
 
 config SYS_SOC
@@ -165,5 +175,6 @@ endif
 source "board/ti/omap5_uevm/Kconfig"
 source "board/ti/dra7xx/Kconfig"
 source "board/ti/am57xx/Kconfig"
+source "board/emacinc/som-5728m/Kconfig"
 
 endif
diff --git a/board/emacinc/common/Kconfig b/board/emacinc/common/Kconfig
new file mode 100644
index 0000000000..9ead7ca038
--- /dev/null
+++ b/board/emacinc/common/Kconfig
@@ -0,0 +1,45 @@
+config TI_I2C_BOARD_DETECT
+	bool "Support for Board detection for TI platforms"
+	help
+	   Support for detection board information on Texas Instrument's
+	   Evaluation Boards which have I2C based EEPROM detection
+
+config EEPROM_BUS_ADDRESS
+	int "Board EEPROM's I2C bus address"
+	range 0 8
+	default 0
+	depends on TI_I2C_BOARD_DETECT
+
+config EEPROM_CHIP_ADDRESS
+	hex "Board EEPROM's I2C chip address"
+	range 0 0xff
+	default 0x50
+	depends on TI_I2C_BOARD_DETECT
+
+config TI_COMMON_CMD_OPTIONS
+	bool "Enable cmd options on TI platforms"
+	imply CMD_ASKENV
+	imply CMD_BOOTZ
+	imply CRC32_VERIFY if ARCH_KEYSTONE
+	imply CMD_DFU if USB_GADGET_DOWNLOAD
+	imply CMD_DHCP
+	imply CMD_EEPROM
+	imply CMD_EXT2
+	imply CMD_EXT4
+	imply CMD_EXT4_WRITE
+	imply CMD_FAT
+	imply FAT_WRITE if CMD_FAT
+	imply CMD_FS_GENERIC
+	imply CMD_GPIO
+	imply CMD_GPT
+	imply CMD_I2C
+	imply CMD_MII
+	imply CMD_MMC
+	imply CMD_PART
+	imply CMD_PING
+	imply CMD_PMIC if DM_PMIC
+	imply CMD_REGULATOR if DM_REGULATOR
+	imply CMD_SF if SPI_FLASH
+	imply CMD_SPI
+	imply CMD_TIME
+	imply CMD_USB if USB
diff --git a/board/emacinc/common/Makefile b/board/emacinc/common/Makefile
new file mode 100644
index 0000000000..cb97f226ae
--- /dev/null
+++ b/board/emacinc/common/Makefile
@@ -0,0 +1,4 @@
+# SPDX-License-Identifier: GPL-2.0+
+# Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+
+obj-${CONFIG_TI_I2C_BOARD_DETECT} += board_detect.o
diff --git a/board/emacinc/common/board_detect.c b/board/emacinc/common/board_detect.c
new file mode 100644
index 0000000000..90e31a27b6
--- /dev/null
+++ b/board/emacinc/common/board_detect.c
@@ -0,0 +1,804 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com/
+ *	Lokesh Vutla
+ *	Steve Kipisz
+ */
+
+#include <common.h>
+#include <eeprom.h>
+#include <log.h>
+#include <net.h>
+#include <asm/arch/hardware.h>
+#include <asm/omap_common.h>
+#include <dm/uclass.h>
+#include <env.h>
+#include <i2c.h>
+#include <mmc.h>
+#include <errno.h>
+#include <malloc.h>
+
+#include "board_detect.h"
+
+#if !defined(CONFIG_DM_I2C)
+/**
+ * ti_i2c_eeprom_init - Initialize an i2c bus and probe for a device
+ * @i2c_bus: i2c bus number to initialize
+ * @dev_addr: Device address to probe for
+ *
+ * Return: 0 on success or corresponding error on failure.
+ */
+static int __maybe_unused ti_i2c_eeprom_init(int i2c_bus, int dev_addr)
+{
+	int rc;
+
+	if (i2c_bus >= 0) {
+		rc = i2c_set_bus_num(i2c_bus);
+		if (rc)
+			return rc;
+	}
+
+	return i2c_probe(dev_addr);
+}
+
+/**
+ * ti_i2c_eeprom_read - Read data from an EEPROM
+ * @dev_addr: The device address of the EEPROM
+ * @offset: Offset to start reading in the EEPROM
+ * @ep: Pointer to a buffer to read into
+ * @epsize: Size of buffer
+ *
+ * Return: 0 on success or corresponding result of i2c_read
+ */
+static int __maybe_unused ti_i2c_eeprom_read(int dev_addr, int offset,
+					     uchar *ep, int epsize)
+{
+	return i2c_read(dev_addr, offset, 2, ep, epsize);
+}
+#endif
+
+/**
+ * ti_eeprom_string_cleanup() - Handle eeprom programming errors
+ * @s:	eeprom string (should be NULL terminated)
+ *
+ * Some Board manufacturers do not add a NULL termination at the
+ * end of string, instead some binary information is kludged in, hence
+ * convert the string to just printable characters of ASCII chart.
+ */
+static void __maybe_unused ti_eeprom_string_cleanup(char *s)
+{
+	int i, l;
+
+	l = strlen(s);
+	for (i = 0; i < l; i++, s++)
+		if (*s < ' ' || *s > '~') {
+			*s = 0;
+			break;
+		}
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
+					    u32 header, u32 size, uint8_t *ep)
+{
+	int rc;
+
+#if defined(CONFIG_DM_I2C)
+	struct udevice *dev;
+	struct udevice *bus;
+
+	rc = uclass_get_device_by_seq(UCLASS_I2C, bus_addr, &bus);
+	if (rc)
+		return rc;
+	rc = dm_i2c_probe(bus, dev_addr, 0, &dev);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	rc = i2c_set_chip_offset_len(dev, 1);
+	if (rc)
+		return rc;
+
+	/*
+	 * Skip checking result here since this could be a valid i2c read fail
+	 * on some boards that use 2 byte addressing.
+	 * We must allow for fall through to check the data if 2 byte
+	 * addressing works
+	 */
+	(void)dm_i2c_read(dev, 0, ep, size);
+
+	/* Corrupted data??? */
+	if (*((u32 *)ep) != header) {
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 2 byte address (some newer boards need this..)
+		 */
+		rc = i2c_set_chip_offset_len(dev, 2);
+		if (rc)
+			return rc;
+
+		rc = dm_i2c_read(dev, 0, ep, size);
+		if (rc)
+			return rc;
+	}
+	if (*((u32 *)ep) != header)
+		return -1;
+#else
+	u32 byte;
+
+	gpi2c_init();
+	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
+	if (rc)
+		return rc;
+
+	/*
+	 * Read the header first then only read the other contents.
+	 */
+	byte = 1;
+
+	/*
+	 * Skip checking result here since this could be a valid i2c read fail
+	 * on some boards that use 2 byte addressing.
+	 * We must allow for fall through to check the data if 2 byte
+	 * addressing works
+	 */
+	(void)i2c_read(dev_addr, 0x0, byte, ep, size);
+
+	/* Corrupted data??? */
+	if (*((u32 *)ep) != header) {
+		/*
+		 * read the eeprom header using i2c again, but use only a
+		 * 2 byte address (some newer boards need this..)
+		 */
+		byte = 2;
+		rc = i2c_read(dev_addr, 0x0, byte, ep, size);
+		if (rc)
+			return rc;
+	}
+	if (*((u32 *)ep) != header)
+		return -1;
+#endif
+	return 0;
+}
+
+int __maybe_unused ti_emmc_boardid_get(void)
+{
+	int rc;
+	struct udevice *dev;
+	struct mmc *mmc;
+	struct ti_common_eeprom *ep;
+	struct ti_am_eeprom brdid;
+	struct blk_desc *bdesc;
+	uchar *buffer;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return 0;       /* EEPROM has already been read */
+
+	/* Initialize with a known bad marker for emmc fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+
+	/* uclass object initialization */
+	rc = mmc_initialize(NULL);
+	if (rc)
+		return rc;
+
+	/* Set device to /dev/mmcblk1 */
+	rc = uclass_get_device(UCLASS_MMC, 1, &dev);
+	if (rc)
+		return rc;
+
+	/* Grab the mmc device */
+	mmc = mmc_get_mmc_dev(dev);
+	if (!mmc)
+		return -ENODEV;
+
+	/* mmc hardware initialization routine */
+	mmc_init(mmc);
+
+	/* Set partition to /dev/mmcblk1boot1 */
+	rc = mmc_switch_part(mmc, 2);
+	if (rc)
+		return rc;
+
+	buffer = malloc(mmc->read_bl_len);
+	if (!buffer)
+		return -ENOMEM;
+
+	bdesc = mmc_get_blk_desc(mmc);
+
+	/* blk_dread returns the number of blocks read*/
+	if (blk_dread(bdesc, 0L, 1, buffer) != 1) {
+		rc = -EIO;
+		goto cleanup;
+	}
+
+	memcpy(&brdid, buffer, sizeof(brdid));
+
+	/* Write out the ep struct values */
+	ep->header = brdid.header;
+	strlcpy(ep->name, brdid.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+	strlcpy(ep->version, brdid.version, TI_EEPROM_HDR_REV_LEN + 1);
+	ti_eeprom_string_cleanup(ep->version);
+	strlcpy(ep->serial, brdid.serial, TI_EEPROM_HDR_SERIAL_LEN + 1);
+	ti_eeprom_string_cleanup(ep->serial);
+
+cleanup:
+	free(buffer);
+
+	return rc;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_set(const char *name, const char *rev)
+{
+	struct ti_common_eeprom *ep;
+
+	if (!name || !rev)
+		return -1;
+
+	ep = TI_EEPROM_DATA;
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		goto already_set;
+
+	/* Set to 0 all fields */
+	memset(ep, 0, sizeof(*ep));
+	strncpy(ep->name, name, TI_EEPROM_HDR_NAME_LEN);
+	strncpy(ep->version, rev, TI_EEPROM_HDR_REV_LEN);
+	/* Some dummy serial number to identify the platform */
+	strncpy(ep->serial, "0000", TI_EEPROM_HDR_SERIAL_LEN);
+	/* Mark it with a valid header */
+	ep->header = TI_EEPROM_HEADER_MAGIC;
+
+already_set:
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am_get(int bus_addr, int dev_addr)
+{
+	int rc;
+	struct ti_am_eeprom am_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(am_ep), (uint8_t *)&am_ep);
+	if (rc)
+		return rc;
+
+	ep->header = am_ep.header;
+	strlcpy(ep->name, am_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	/* BeagleBone Green '1' eeprom, board_rev: 0x1a 0x00 0x00 0x00 */
+	if (am_ep.version[0] == 0x1a && am_ep.version[1] == 0x00 &&
+	    am_ep.version[2] == 0x00 && am_ep.version[3] == 0x00)
+		strlcpy(ep->version, "BBG1", TI_EEPROM_HDR_REV_LEN + 1);
+	else
+		strlcpy(ep->version, am_ep.version, TI_EEPROM_HDR_REV_LEN + 1);
+	ti_eeprom_string_cleanup(ep->version);
+	strlcpy(ep->serial, am_ep.serial, TI_EEPROM_HDR_SERIAL_LEN + 1);
+	ti_eeprom_string_cleanup(ep->serial);
+	strlcpy(ep->config, am_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	memcpy(ep->mac_addr, am_ep.mac_addr,
+	       TI_EEPROM_HDR_NO_OF_MAC_ADDR * TI_EEPROM_HDR_ETH_ALEN);
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr)
+{
+	int rc, offset = 0;
+	struct dra7_eeprom dra7_ep;
+	struct ti_common_eeprom *ep;
+
+	ep = TI_EEPROM_DATA;
+#ifndef CONFIG_SPL_BUILD
+	if (ep->header == DRA7_EEPROM_HEADER_MAGIC)
+		return 0; /* EEPROM has already been read */
+#endif
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+	ep->name[0] = 0x0;
+	ep->version[0] = 0x0;
+	ep->serial[0] = 0x0;
+	ep->config[0] = 0x0;
+	ep->emif1_size = 0;
+	ep->emif2_size = 0;
+
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, DRA7_EEPROM_HEADER_MAGIC,
+			       sizeof(dra7_ep), (uint8_t *)&dra7_ep);
+	if (rc)
+		return rc;
+
+	ep->header = dra7_ep.header;
+	strlcpy(ep->name, dra7_ep.name, TI_EEPROM_HDR_NAME_LEN + 1);
+	ti_eeprom_string_cleanup(ep->name);
+
+	offset = dra7_ep.version_major - 1;
+
+	/* Rev F is skipped */
+	if (offset >= 5)
+		offset = offset + 1;
+	snprintf(ep->version, TI_EEPROM_HDR_REV_LEN + 1, "%c.%d",
+		 'A' + offset, dra7_ep.version_minor);
+	ti_eeprom_string_cleanup(ep->version);
+	ep->emif1_size = (u64)dra7_ep.emif1_size;
+	ep->emif2_size = (u64)dra7_ep.emif2_size;
+	strlcpy(ep->config, dra7_ep.config, TI_EEPROM_HDR_CONFIG_LEN + 1);
+	ti_eeprom_string_cleanup(ep->config);
+
+	return 0;
+}
+
+static int ti_i2c_eeprom_am6_parse_record(struct ti_am6_eeprom_record *record,
+					  struct ti_am6_eeprom *ep,
+					  char **mac_addr,
+					  u8 mac_addr_max_cnt,
+					  u8 *mac_addr_cnt)
+{
+	switch (record->header.id) {
+	case TI_AM6_EEPROM_RECORD_BOARD_INFO:
+		if (record->header.len != sizeof(record->data.board_info))
+			return -EINVAL;
+
+		if (!ep)
+			break;
+
+		/* Populate (and clean, if needed) the board name */
+		strlcpy(ep->name, record->data.board_info.name,
+			sizeof(ep->name));
+		ti_eeprom_string_cleanup(ep->name);
+
+		/* Populate selected other fields from the board info record */
+		strlcpy(ep->version, record->data.board_info.version,
+			sizeof(ep->version));
+		strlcpy(ep->software_revision,
+			record->data.board_info.software_revision,
+			sizeof(ep->software_revision));
+		strlcpy(ep->serial, record->data.board_info.serial,
+			sizeof(ep->serial));
+		break;
+	case TI_AM6_EEPROM_RECORD_MAC_INFO:
+		if (record->header.len != sizeof(record->data.mac_info))
+			return -EINVAL;
+
+		if (!mac_addr || !mac_addr_max_cnt)
+			break;
+
+		*mac_addr_cnt = ((record->data.mac_info.mac_control &
+				 TI_AM6_EEPROM_MAC_ADDR_COUNT_MASK) >>
+				 TI_AM6_EEPROM_MAC_ADDR_COUNT_SHIFT) + 1;
+
+		/*
+		 * The EEPROM can (but may not) hold a very large amount
+		 * of MAC addresses, by far exceeding what we want/can store
+		 * in the common memory array, so only grab what we can fit.
+		 * Note that a value of 0 means 1 MAC address, and so on.
+		 */
+		*mac_addr_cnt = min(*mac_addr_cnt, mac_addr_max_cnt);
+
+		memcpy(mac_addr, record->data.mac_info.mac_addr,
+		       *mac_addr_cnt * TI_EEPROM_HDR_ETH_ALEN);
+		break;
+	case 0x00:
+		/* Illegal value... Fall through... */
+	case 0xFF:
+		/* Illegal value... Something went horribly wrong... */
+		return -EINVAL;
+	default:
+		pr_warn("%s: Ignoring record id %u\n", __func__,
+			record->header.id);
+	}
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am6_get(int bus_addr, int dev_addr,
+					 struct ti_am6_eeprom *ep,
+					 char **mac_addr,
+					 u8 mac_addr_max_cnt,
+					 u8 *mac_addr_cnt)
+{
+	struct udevice *dev;
+	struct udevice *bus;
+	unsigned int eeprom_addr;
+	struct ti_am6_eeprom_record_board_id board_id;
+	struct ti_am6_eeprom_record record;
+	int rc;
+	int consecutive_bad_records = 0;
+
+	/* Initialize with a known bad marker for i2c fails.. */
+	memset(ep, 0, sizeof(*ep));
+	ep->header = TI_DEAD_EEPROM_MAGIC;
+
+	/* Read the board ID record which is always the first EEPROM record */
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(board_id), (uint8_t *)&board_id);
+	if (rc)
+		return rc;
+
+	/*
+	 * Handle case of bad 2 byte eeproms that responds to 1 byte addressing
+	 * but gets stuck in const addressing when read requests are performed
+	 * on offsets. We re-read the board ID to ensure we have sane data back
+	 */
+	rc = ti_i2c_eeprom_get(bus_addr, dev_addr, TI_EEPROM_HEADER_MAGIC,
+			       sizeof(board_id), (uint8_t *)&board_id);
+	if (rc)
+		return rc;
+
+	if (board_id.header.id != TI_AM6_EEPROM_RECORD_BOARD_ID) {
+		pr_err("%s: Invalid board ID record!\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Establish DM handle to board config EEPROM */
+	rc = uclass_get_device_by_seq(UCLASS_I2C, bus_addr, &bus);
+	if (rc)
+		return rc;
+	rc = i2c_get_chip(bus, dev_addr, 1, &dev);
+	if (rc)
+		return rc;
+
+	ep->header = TI_EEPROM_HEADER_MAGIC;
+
+	/* Ready to parse TLV structure. Initialize variables... */
+	*mac_addr_cnt = 0;
+
+	/*
+	 * After the all-encompassing board ID record all other records follow
+	 * a TLV-type scheme. Point to the first such record and then start
+	 * parsing those one by one.
+	 */
+	eeprom_addr = sizeof(board_id);
+
+	while (consecutive_bad_records < 10) {
+		rc = dm_i2c_read(dev, eeprom_addr, (uint8_t *)&record.header,
+				 sizeof(record.header));
+		if (rc)
+			return rc;
+
+		/*
+		 * Check for end of list marker. If we reached it don't go
+		 * any further and stop parsing right here.
+		 */
+		if (record.header.id == TI_AM6_EEPROM_RECORD_END_LIST)
+			break;
+
+		eeprom_addr += sizeof(record.header);
+
+		debug("%s: dev_addr=0x%02x header.id=%u header.len=%u\n",
+		      __func__, dev_addr, record.header.id,
+		      record.header.len);
+
+		/* Read record into memory if it fits */
+		if (record.header.len <= sizeof(record.data)) {
+			rc = dm_i2c_read(dev, eeprom_addr,
+					 (uint8_t *)&record.data,
+					 record.header.len);
+			if (rc)
+				return rc;
+
+			/* Process record */
+			rc = ti_i2c_eeprom_am6_parse_record(&record, ep,
+							    mac_addr,
+							    mac_addr_max_cnt,
+							    mac_addr_cnt);
+			if (rc) {
+				pr_err("%s: EEPROM parsing error!\n", __func__);
+				return rc;
+			}
+			consecutive_bad_records = 0;
+		} else {
+			/*
+			 * We may get here in case of larger records which
+			 * are not yet understood.
+			 */
+			pr_err("%s: Ignoring record id %u\n", __func__,
+			       record.header.id);
+			consecutive_bad_records++;
+		}
+
+		eeprom_addr += record.header.len;
+	}
+
+	return 0;
+}
+
+int __maybe_unused ti_i2c_eeprom_am6_get_base(int bus_addr, int dev_addr)
+{
+	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
+	int ret;
+
+	/*
+	 * Always execute EEPROM read by not allowing to bypass it during the
+	 * first invocation of SPL which happens on the R5 core.
+	 */
+#if !(defined(CONFIG_SPL_BUILD) && defined(CONFIG_CPU_V7R))
+	if (ep->header == TI_EEPROM_HEADER_MAGIC) {
+		debug("%s: EEPROM has already been read\n", __func__);
+		return 0;
+	}
+#endif
+
+	ret = ti_i2c_eeprom_am6_get(bus_addr, dev_addr, ep,
+				    (char **)ep->mac_addr,
+				    AM6_EEPROM_HDR_NO_OF_MAC_ADDR,
+				    &ep->mac_addr_cnt);
+	return ret;
+}
+
+bool __maybe_unused board_ti_k3_is(char *name_tag)
+{
+	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+	return !strncmp(ep->name, name_tag, AM6_EEPROM_HDR_NAME_LEN);
+}
+
+bool __maybe_unused board_ti_is(char *name_tag)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+	return !strncmp(ep->name, name_tag, TI_EEPROM_HDR_NAME_LEN);
+}
+
+bool __maybe_unused board_ti_rev_is(char *rev_tag, int cmp_len)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+	int l;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		return false;
+
+	l = cmp_len > TI_EEPROM_HDR_REV_LEN ? TI_EEPROM_HDR_REV_LEN : cmp_len;
+	return !strncmp(ep->version, rev_tag, l);
+}
+
+char * __maybe_unused board_ti_get_rev(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->version;
+}
+
+char * __maybe_unused board_ti_get_config(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->config;
+}
+
+char * __maybe_unused board_ti_get_name(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	/* if ep->header == TI_DEAD_EEPROM_MAGIC, this is empty already */
+	return ep->name;
+}
+
+void __maybe_unused
+board_ti_get_eth_mac_addr(int index,
+			  u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN])
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= TI_EEPROM_HDR_NO_OF_MAC_ADDR)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+}
+
+void __maybe_unused
+board_ti_am6_get_eth_mac_addr(int index,
+			      u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN])
+{
+	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
+
+	if (ep->header == TI_DEAD_EEPROM_MAGIC)
+		goto fail;
+
+	if (index < 0 || index >= ep->mac_addr_cnt)
+		goto fail;
+
+	memcpy(mac_addr, ep->mac_addr[index], TI_EEPROM_HDR_ETH_ALEN);
+	return;
+
+fail:
+	memset(mac_addr, 0, TI_EEPROM_HDR_ETH_ALEN);
+}
+
+u64 __maybe_unused board_ti_get_emif1_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif1_size;
+}
+
+u64 __maybe_unused board_ti_get_emif2_size(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header != DRA7_EEPROM_HEADER_MAGIC)
+		return 0;
+
+	return ep->emif2_size;
+}
+
+void __maybe_unused set_board_info_env(char *name)
+{
+	char *unknown = "unknown";
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (name)
+		env_set("board_name", name);
+	else if (strlen(ep->name) != 0)
+		env_set("board_name", ep->name);
+	else
+		env_set("board_name", unknown);
+
+	if (strlen(ep->version) != 0)
+		env_set("board_rev", ep->version);
+	else
+		env_set("board_rev", unknown);
+
+	if (strlen(ep->serial) != 0)
+		env_set("board_serial", ep->serial);
+	else
+		env_set("board_serial", unknown);
+}
+
+void __maybe_unused set_board_info_env_am6(char *name)
+{
+	char *unknown = "unknown";
+	struct ti_am6_eeprom *ep = TI_AM6_EEPROM_DATA;
+
+	if (name)
+		env_set("board_name", name);
+	else if (strlen(ep->name) != 0)
+		env_set("board_name", ep->name);
+	else
+		env_set("board_name", unknown);
+
+	if (strlen(ep->version) != 0)
+		env_set("board_rev", ep->version);
+	else
+		env_set("board_rev", unknown);
+
+	if (strlen(ep->software_revision) != 0)
+		env_set("board_software_revision", ep->software_revision);
+	else
+		env_set("board_software_revision", unknown);
+
+	if (strlen(ep->serial) != 0)
+		env_set("board_serial", ep->serial);
+	else
+		env_set("board_serial", unknown);
+}
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+void board_ti_set_ethaddr(int index)
+{
+	uint8_t mac_addr[6];
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+	/*
+	 * Export any Ethernet MAC addresses from EEPROM.
+	 * The 2 MAC addresses in EEPROM define the address range.
+	 */
+	board_ti_get_eth_mac_addr(0, mac_addr1);
+	board_ti_get_eth_mac_addr(1, mac_addr2);
+
+	if (is_valid_ethaddr(mac_addr1) && is_valid_ethaddr(mac_addr2)) {
+		mac1 = mac_to_u64(mac_addr1);
+		mac2 = mac_to_u64(mac_addr2);
+
+		/* must contain an address range */
+		num_macs = mac2 - mac1 + 1;
+		if (num_macs <= 0)
+			return;
+
+		if (num_macs > 50) {
+			printf("%s: Too many MAC addresses: %d. Limiting to 50\n",
+			       __func__, num_macs);
+			num_macs = 50;
+		}
+
+		for (i = 0; i < num_macs; i++) {
+			u64_to_mac(mac1 + i, mac_addr);
+			if (is_valid_ethaddr(mac_addr)) {
+				eth_env_set_enetaddr_by_index("eth", i + index,
+							      mac_addr);
+			}
+		}
+	}
+}
+
+void board_ti_am6_set_ethaddr(int index, int count)
+{
+	u8 mac_addr[6];
+	int i;
+
+	for (i = 0; i < count; i++) {
+		board_ti_am6_get_eth_mac_addr(i, mac_addr);
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr_by_index("eth", i + index,
+						      mac_addr);
+	}
+}
+
+bool __maybe_unused board_ti_was_eeprom_read(void)
+{
+	struct ti_common_eeprom *ep = TI_EEPROM_DATA;
+
+	if (ep->header == TI_EEPROM_HEADER_MAGIC)
+		return true;
+	else
+		return false;
+}
diff --git a/board/emacinc/common/board_detect.h b/board/emacinc/common/board_detect.h
new file mode 100644
index 0000000000..de7cb52dfc
--- /dev/null
+++ b/board/emacinc/common/board_detect.h
@@ -0,0 +1,471 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Library to support early TI EVM EEPROM handling
+ *
+ * Copyright (C) 2015-2016 Texas Instruments Incorporated - http://www.ti.com
+ */
+
+#ifndef __BOARD_DETECT_H
+#define __BOARD_DETECT_H
+
+/* TI EEPROM MAGIC Header identifier */
+#include <linux/bitops.h>
+#define TI_EEPROM_HEADER_MAGIC	0xEE3355AA
+#define TI_DEAD_EEPROM_MAGIC	0xADEAD12C
+
+#define TI_EEPROM_HDR_NAME_LEN		8
+#define TI_EEPROM_HDR_REV_LEN		4
+#define TI_EEPROM_HDR_SERIAL_LEN	12
+#define TI_EEPROM_HDR_CONFIG_LEN	32
+#define TI_EEPROM_HDR_NO_OF_MAC_ADDR	3
+#define TI_EEPROM_HDR_ETH_ALEN		6
+
+/**
+ * struct ti_am_eeprom - This structure holds data read in from the
+ *                     AM335x, AM437x, AM57xx TI EVM EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version: Board revision
+ * @serial: Board serial number
+ * @config: Reserved
+ * @mac_addr: Any MAC addresses written in the EEPROM
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific TI boards. This allows booting of multiple
+ * TI boards with a single MLO and u-boot.
+ */
+struct ti_am_eeprom {
+	unsigned int header;
+	char name[TI_EEPROM_HDR_NAME_LEN];
+	char version[TI_EEPROM_HDR_REV_LEN];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN];
+	char config[TI_EEPROM_HDR_CONFIG_LEN];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+} __attribute__ ((__packed__));
+
+/* AM6x TI EVM EEPROM Definitions */
+#define TI_AM6_EEPROM_RECORD_BOARD_ID		0x01
+#define TI_AM6_EEPROM_RECORD_BOARD_INFO		0x10
+#define TI_AM6_EEPROM_RECORD_DDR_INFO		0x11
+#define TI_AM6_EEPROM_RECORD_DDR_SPD		0x12
+#define TI_AM6_EEPROM_RECORD_MAC_INFO		0x13
+#define TI_AM6_EEPROM_RECORD_END_LIST		0xFE
+
+/*
+ * Common header for AM6x TI EVM EEPROM records. Used to encapsulate the config
+ * EEPROM in its entirety as well as for individual records contained within.
+ */
+struct ti_am6_eeprom_record_header {
+	u8 id;
+	u16 len;
+} __attribute__ ((__packed__));
+
+/* AM6x TI EVM EEPROM board ID structure */
+struct ti_am6_eeprom_record_board_id {
+	u32 magic_number;
+	struct ti_am6_eeprom_record_header header;
+} __attribute__ ((__packed__));
+
+/* AM6x TI EVM EEPROM board info structure */
+#define AM6_EEPROM_HDR_NAME_LEN			16
+#define AM6_EEPROM_HDR_VERSION_LEN		2
+#define AM6_EEPROM_HDR_PROC_NR_LEN		4
+#define AM6_EEPROM_HDR_VARIANT_LEN		2
+#define AM6_EEPROM_HDR_PCB_REV_LEN		2
+#define AM6_EEPROM_HDR_SCH_BOM_REV_LEN		2
+#define AM6_EEPROM_HDR_SW_REV_LEN		2
+#define AM6_EEPROM_HDR_VID_LEN			2
+#define AM6_EEPROM_HDR_BLD_WK_LEN		2
+#define AM6_EEPROM_HDR_BLD_YR_LEN		2
+#define AM6_EEPROM_HDR_4P_NR_LEN		6
+#define AM6_EEPROM_HDR_SERIAL_LEN		4
+
+struct ti_am6_eeprom_record_board_info {
+	char name[AM6_EEPROM_HDR_NAME_LEN];
+	char version[AM6_EEPROM_HDR_VERSION_LEN];
+	char proc_number[AM6_EEPROM_HDR_PROC_NR_LEN];
+	char variant[AM6_EEPROM_HDR_VARIANT_LEN];
+	char pcb_revision[AM6_EEPROM_HDR_PCB_REV_LEN];
+	char schematic_bom_revision[AM6_EEPROM_HDR_SCH_BOM_REV_LEN];
+	char software_revision[AM6_EEPROM_HDR_SW_REV_LEN];
+	char vendor_id[AM6_EEPROM_HDR_VID_LEN];
+	char build_week[AM6_EEPROM_HDR_BLD_WK_LEN];
+	char build_year[AM6_EEPROM_HDR_BLD_YR_LEN];
+	char board_4p_number[AM6_EEPROM_HDR_4P_NR_LEN];
+	char serial[AM6_EEPROM_HDR_SERIAL_LEN];
+} __attribute__ ((__packed__));
+
+/* Memory location to keep a copy of the AM6 board info record */
+#define TI_AM6_EEPROM_BD_INFO_DATA ((struct ti_am6_eeprom_record_board_info *) \
+					     TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/* AM6x TI EVM EEPROM DDR info structure */
+#define TI_AM6_EEPROM_DDR_CTRL_INSTANCE_MASK		GENMASK(1, 0)
+#define TI_AM6_EEPROM_DDR_CTRL_INSTANCE_SHIFT		0
+#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_MASK	GENMASK(3, 2)
+#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_NA		(0 << 2)
+#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_BOARDID	(2 << 2)
+#define TI_AM6_EEPROM_DDR_CTRL_SPD_DATA_LOC_I2C51	(3 << 2)
+#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_MASK		GENMASK(5, 4)
+#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_DDR3		(0 << 4)
+#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_DDR4		(1 << 4)
+#define TI_AM6_EEPROM_DDR_CTRL_MEM_TYPE_LPDDR4		(2 << 4)
+#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_MASK	GENMASK(7, 6)
+#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_16		(0 << 6)
+#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_32		(1 << 6)
+#define TI_AM6_EEPROM_DDR_CTRL_IF_DATA_WIDTH_64		(2 << 6)
+#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_MASK	GENMASK(9, 8)
+#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_8		(0 << 8)
+#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_16	(1 << 8)
+#define TI_AM6_EEPROM_DDR_CTRL_DEV_DATA_WIDTH_32	(2 << 8)
+#define TI_AM6_EEPROM_DDR_CTRL_RANKS_2			BIT(10)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_MASK		GENMASK(13, 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_1GB			(0 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_2GB			(1 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_4GB			(2 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_8GB			(3 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_12GB		(4 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_16GB		(5 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_24GB		(6 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_DENS_32GB		(7 << 11)
+#define TI_AM6_EEPROM_DDR_CTRL_ECC			BIT(14)
+
+struct ti_am6_eeprom_record_ddr_info {
+	u16 ddr_control;
+} __attribute__ ((__packed__));
+
+/* AM6x TI EVM EEPROM DDR SPD structure */
+#define TI_AM6_EEPROM_DDR_SPD_INSTANCE_MASK		GENMASK(1, 0)
+#define TI_AM6_EEPROM_DDR_SPD_INSTANCE_SHIFT		0
+#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_MASK		GENMASK(4, 3)
+#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_DDR3		(0 << 3)
+#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_DDR4		(1 << 3)
+#define TI_AM6_EEPROM_DDR_SPD_MEM_TYPE_LPDDR4		(2 << 3)
+#define TI_AM6_EEPROM_DDR_SPD_DATA_LEN			512
+
+struct ti_am6_eeprom_record_ddr_spd {
+	u16 spd_control;
+	u8 data[TI_AM6_EEPROM_DDR_SPD_DATA_LEN];
+} __attribute__ ((__packed__));
+
+/* AM6x TI EVM EEPROM MAC info structure */
+#define TI_AM6_EEPROM_MAC_INFO_INSTANCE_MASK		GENMASK(2, 0)
+#define TI_AM6_EEPROM_MAC_INFO_INSTANCE_SHIFT		0
+#define TI_AM6_EEPROM_MAC_ADDR_COUNT_MASK		GENMASK(7, 3)
+#define TI_AM6_EEPROM_MAC_ADDR_COUNT_SHIFT		3
+#define TI_AM6_EEPROM_MAC_ADDR_MAX_COUNT		32
+
+struct ti_am6_eeprom_record_mac_info {
+	u16 mac_control;
+	u8 mac_addr[TI_AM6_EEPROM_MAC_ADDR_MAX_COUNT][TI_EEPROM_HDR_ETH_ALEN];
+} __attribute__ ((__packed__));
+
+struct ti_am6_eeprom_record {
+	struct ti_am6_eeprom_record_header header;
+	union {
+		struct ti_am6_eeprom_record_board_info board_info;
+		struct ti_am6_eeprom_record_ddr_info ddr_info;
+		struct ti_am6_eeprom_record_ddr_spd ddr_spd;
+		struct ti_am6_eeprom_record_mac_info mac_info;
+	} data;
+} __attribute__ ((__packed__));
+
+/* DRA7 EEPROM MAGIC Header identifier */
+#define DRA7_EEPROM_HEADER_MAGIC	0xAA5533EE
+#define DRA7_EEPROM_HDR_NAME_LEN	16
+#define DRA7_EEPROM_HDR_CONFIG_LEN	4
+
+/**
+ * struct dra7_eeprom - This structure holds data read in from the DRA7 EVM
+ *			EEPROMs.
+ * @header: This holds the magic number
+ * @name: The name of the board
+ * @version_major: Board major version
+ * @version_minor: Board minor version
+ * @config: Board specific config options
+ * @emif1_size: Size of DDR attached to EMIF1
+ * @emif2_size: Size of DDR attached to EMIF2
+ *
+ * The data is this structure is read from the EEPROM on the board.
+ * It is used for board detection which is based on name. It is used
+ * to configure specific DRA7 boards. This allows booting of multiple
+ * DRA7 boards with a single MLO and u-boot.
+ */
+struct dra7_eeprom {
+	u32 header;
+	char name[DRA7_EEPROM_HDR_NAME_LEN];
+	u16 version_major;
+	u16 version_minor;
+	char config[DRA7_EEPROM_HDR_CONFIG_LEN];
+	u32 emif1_size;
+	u32 emif2_size;
+} __attribute__ ((__packed__));
+
+/**
+ * struct ti_common_eeprom - Null terminated, usable EEPROM contents.
+ * header:	Magic number
+ * @name:	NULL terminated name
+ * @version:	NULL terminated version
+ * @serial:	NULL terminated serial number
+ * @config:	NULL terminated Board specific config options
+ * @mac_addr:	MAC addresses
+ * @emif1_size:	Size of the ddr available on emif1
+ * @emif2_size:	Size of the ddr available on emif2
+ */
+struct ti_common_eeprom {
+	u32 header;
+	char name[TI_EEPROM_HDR_NAME_LEN + 1];
+	char version[TI_EEPROM_HDR_REV_LEN + 1];
+	char serial[TI_EEPROM_HDR_SERIAL_LEN + 1];
+	char config[TI_EEPROM_HDR_CONFIG_LEN + 1];
+	char mac_addr[TI_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+	u64 emif1_size;
+	u64 emif2_size;
+};
+
+#define TI_EEPROM_DATA ((struct ti_common_eeprom *)\
+				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/*
+ * Maximum number of Ethernet MAC addresses extracted from the AM6x on-board
+ * EEPROM during the initial probe and carried forward in SRAM.
+ */
+#define AM6_EEPROM_HDR_NO_OF_MAC_ADDR	8
+
+/**
+ * struct ti_am6_eeprom - Null terminated, usable EEPROM contents, as extracted
+ *	from the AM6 on-board EEPROM. Note that we only carry a subset of data
+ *	at this time to be considerate about memory consumption.
+ * @header:		Magic number for data validity indication
+ * @name:		NULL terminated name
+ * @version:		NULL terminated version
+ * @software_revision:	NULL terminated software revision
+ * @serial:		Board serial number
+ * @mac_addr_cnt:	Number of MAC addresses stored in this object
+ * @mac_addr:		MAC addresses
+ */
+struct ti_am6_eeprom {
+	u32 header;
+	char name[AM6_EEPROM_HDR_NAME_LEN + 1];
+	char version[AM6_EEPROM_HDR_VERSION_LEN + 1];
+	char software_revision[AM6_EEPROM_HDR_SW_REV_LEN + 1];
+	char serial[AM6_EEPROM_HDR_SERIAL_LEN + 1];
+	u8 mac_addr_cnt;
+	char mac_addr[AM6_EEPROM_HDR_NO_OF_MAC_ADDR][TI_EEPROM_HDR_ETH_ALEN];
+};
+
+#define TI_AM6_EEPROM_DATA ((struct ti_am6_eeprom *) \
+				TI_SRAM_SCRATCH_BOARD_EEPROM_START)
+
+/**
+ * ti_i2c_eeprom_am_get() - Consolidated eeprom data collection for AM* TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ *
+ * ep in SRAM is populated by the this AM generic function that consolidates
+ * the basic initialization logic common across all AM* platforms.
+ */
+int ti_i2c_eeprom_am_get(int bus_addr, int dev_addr);
+
+/**
+ * ti_emmc_boardid_get() - Fetch board ID information from eMMC
+ *
+ * ep in SRAM is populated by the this function that is currently
+ * based on BeagleBone AI, but could be made more general across AM*
+ * platforms.
+ */
+int __maybe_unused ti_emmc_boardid_get(void);
+
+/**
+ * ti_i2c_eeprom_dra7_get() - Consolidated eeprom data for DRA7 TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ */
+int ti_i2c_eeprom_dra7_get(int bus_addr, int dev_addr);
+
+/**
+ * ti_i2c_eeprom_am6_get() - Consolidated eeprom data for AM6x TI EVMs and
+ *			     associated daughter cards, parsed into user-
+ *			     provided data structures
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ * @ep:		Pointer to structure receiving AM6-specific header data
+ * @mac_addr:	Pointer to memory receiving parsed MAC addresses. May be
+ *		NULL to skip MAC parsing.
+ * @mac_addr_max_cnt: Maximum number of MAC addresses that can be stored into
+ *		      mac_addr. May be NULL to skip MAC parsing.
+ * @mac_addr_cnt: Pointer to a location returning how many MAC addressed got
+ *		  actually parsed.
+ */
+int __maybe_unused ti_i2c_eeprom_am6_get(int bus_addr, int dev_addr,
+					 struct ti_am6_eeprom *ep,
+					 char **mac_addr,
+					 u8 mac_addr_max_cnt,
+					 u8 *mac_addr_cnt);
+
+/**
+ * ti_i2c_eeprom_am6_get_base() - Consolidated eeprom data for AM6x TI EVMs
+ * @bus_addr:	I2C bus address
+ * @dev_addr:	I2C slave address
+ */
+int __maybe_unused ti_i2c_eeprom_am6_get_base(int bus_addr, int dev_addr);
+
+#ifdef CONFIG_TI_I2C_BOARD_DETECT
+/**
+ * board_ti_is() - Board detection logic for TI EVMs
+ * @name_tag:	Tag used in eeprom for the board
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_is(char *name_tag);
+
+/**
+ * board_ti_k3_is() - Board detection logic for TI K3 EVMs
+ * @name_tag:	Tag used in eeprom for the board
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_k3_is(char *name_tag);
+
+/**
+ * board_ti_rev_is() - Compare board revision for TI EVMs
+ * @rev_tag:	Revision tag to check in eeprom
+ * @cmp_len:	How many chars to compare?
+ *
+ * NOTE: revision information is often messed up (hence the str len match) :(
+ *
+ * Return: false if board information does not match OR eeprom wasn't read.
+ *	   true otherwise
+ */
+bool board_ti_rev_is(char *rev_tag, int cmp_len);
+
+/**
+ * board_ti_get_rev() - Get board revision for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board revision otherwise
+ */
+char *board_ti_get_rev(void);
+
+/**
+ * board_ti_get_config() - Get board config for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board config otherwise
+ */
+char *board_ti_get_config(void);
+
+/**
+ * board_ti_get_name() - Get board name for TI EVMs
+ *
+ * Return: Empty string if eeprom wasn't read.
+ *	   Board name otherwise
+ */
+char *board_ti_get_name(void);
+
+/**
+ * board_ti_get_eth_mac_addr() - Get Ethernet MAC address from EEPROM MAC list
+ * @index:	0 based index within the list of MAC addresses
+ * @mac_addr:	MAC address contained at the index is returned here
+ *
+ * Does not sanity check the mac_addr. Whatever is stored in EEPROM is returned.
+ */
+void board_ti_get_eth_mac_addr(int index, u8 mac_addr[TI_EEPROM_HDR_ETH_ALEN]);
+
+/**
+ * board_ti_get_emif1_size() - Get size of the DDR on emif1 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif1_size is not available.
+ */
+u64 board_ti_get_emif1_size(void);
+
+/**
+ * board_ti_get_emif2_size() - Get size of the DDR on emif2 for TI EVMs
+ *
+ * Return: NULL if eeprom wasn't read or emif2_size is not available.
+ */
+u64 board_ti_get_emif2_size(void);
+
+/**
+ * set_board_info_env() - Setup commonly used board information environment vars
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env(char *name);
+
+/**
+ * set_board_info_env_am6() - Setup commonly used board information environment
+ *			      vars for AM6-type boards
+ * @name:	Name of the board
+ *
+ * If name is NULL, default_name is used.
+ */
+void set_board_info_env_am6(char *name);
+
+/**
+ * board_ti_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ *
+ * EEPROM should be already read before calling this function.
+ * The EEPROM contains 2 MAC addresses which define the MAC address
+ * range (i.e. first and last MAC address).
+ * This function sets the ethaddr environment variable for all
+ * the available MAC addresses starting from eth<index>addr.
+ */
+void board_ti_set_ethaddr(int index);
+
+/**
+ * board_ti_am6_set_ethaddr- Sets the ethaddr environment from EEPROM
+ * @index: The first eth<index>addr environment variable to set
+ * @count: The number of MAC addresses to process
+ *
+ * EEPROM should be already read before calling this function. The EEPROM
+ * contains n dedicated MAC addresses. This function sets the ethaddr
+ * environment variable for all the available MAC addresses starting
+ * from eth<index>addr.
+ */
+void board_ti_am6_set_ethaddr(int index, int count);
+
+/**
+ * board_ti_was_eeprom_read() - Check to see if the eeprom contents have been read
+ *
+ * This function is useful to determine if the eeprom has already been read and
+ * its contents have already been loaded into memory. It utiltzes the magic
+ * number that the header value is set to upon successful eeprom read.
+ */
+bool board_ti_was_eeprom_read(void);
+
+/**
+ * ti_i2c_eeprom_am_set() - Setup the eeprom data with predefined values
+ * @name:	Name of the board
+ * @rev:	Revision of the board
+ *
+ * In some cases such as in RTC-only mode, we are able to skip reading eeprom
+ * and wasting i2c based initialization time by using predefined flags for
+ * detecting what platform we are booting on. For those platforms, provide
+ * a handy function to pre-program information.
+ *
+ * NOTE: many eeprom information such as serial number, mac address etc is not
+ * available.
+ *
+ * Return: 0 if all went fine, else return error.
+ */
+int ti_i2c_eeprom_am_set(const char *name, const char *rev);
+#else
+static inline bool board_ti_is(char *name_tag) { return false; };
+static inline bool board_ti_k3_is(char *name_tag) { return false; };
+static inline bool board_ti_rev_is(char *rev_tag, int cmp_len)
+{ return false; };
+static inline char *board_ti_get_rev(void) { return NULL; };
+static inline char *board_ti_get_config(void) { return NULL; };
+static inline char *board_ti_get_name(void) { return NULL; };
+static inline bool board_ti_was_eeprom_read(void) { return false; };
+static inline int ti_i2c_eeprom_am_set(const char *name, const char *rev)
+{ return -EINVAL; };
+#endif
+
+#endif	/* __BOARD_DETECT_H */
diff --git a/board/emacinc/som-5728m/Kconfig b/board/emacinc/som-5728m/Kconfig
new file mode 100644
index 0000000000..e3b3c81a8b
--- /dev/null
+++ b/board/emacinc/som-5728m/Kconfig
@@ -0,0 +1,14 @@
+if TARGET_EMAC_SOM_5728M
+
+config SYS_BOARD
+	default "som-5728m"
+
+config SYS_VENDOR
+	default "emacinc"
+
+config SYS_CONFIG_NAME
+	default "emac-som-5728m"
+
+source "board/emacinc/common/Kconfig"
+
+endif
diff --git a/board/emacinc/som-5728m/MAINTAINERS b/board/emacinc/som-5728m/MAINTAINERS
new file mode 100644
index 0000000000..eaa75a1135
--- /dev/null
+++ b/board/emacinc/som-5728m/MAINTAINERS
@@ -0,0 +1,8 @@
+EMAC SoM-5728M
+M:	Brenden Tisler <support@emacinc.com.com>
+S:	Maintained
+F:	arch/arm/dts/emac-som-5728m.dtsi
+F:	arch/arm/dts/emac-som-5728m-350es.dts
+F:	board/emacinc/som-5728m/
+F:	include/configs/emac-som-5728m.h
+F:	configs/emac-som-5728m_defconfig
diff --git a/board/emacinc/som-5728m/Makefile b/board/emacinc/som-5728m/Makefile
new file mode 100644
index 0000000000..2a6fb9e42c
--- /dev/null
+++ b/board/emacinc/som-5728m/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# (C) Copyright 2014
+# Texas Instruments, <www.ti.com>
+
+obj-y	:= board.o
diff --git a/board/emacinc/som-5728m/board.c b/board/emacinc/som-5728m/board.c
new file mode 100644
index 0000000000..bfd35059ef
--- /dev/null
+++ b/board/emacinc/som-5728m/board.c
@@ -0,0 +1,672 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2023 EMAC Incorporated - http://www.emacinc.com
+ *
+ * Author: Brenden Tisler <support@emacinc.com>
+ *
+ * Based on board/ti/am57xx/board.c
+ */
+
+#include <common.h>
+#include <env.h>
+#include <fdt_support.h>
+#include <image.h>
+#include <init.h>
+#include <malloc.h>
+#include <net.h>
+#include <palmas.h>
+#include <sata.h>
+#include <serial.h>
+#include <usb.h>
+#include <errno.h>
+#ifdef CONFIG_SPL_BUILD
+#include <spl.h>
+#endif
+#include <asm/omap_common.h>
+#include <asm/omap_sec_common.h>
+#include <asm/emif.h>
+#include <asm/gpio.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/dra7xx_iodelay.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/arch/mmc_host_def.h>
+#include <asm/arch/sata.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/omap.h>
+#include <usb.h>
+#include <linux/usb/gadget.h>
+#include <dwc3-uboot.h>
+#include <dwc3-omap-uboot.h>
+#include <ti-usb-phy-uboot.h>
+#include <mmc.h>
+#include <phy.h>
+#include <dm/device.h>
+#include <dm/uclass.h>
+//#include <hang.h>
+
+#include "../common/board_detect.h"
+#include "mux_data.h"
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+static int board_bootmode_has_emmc(void);
+#endif
+
+#define board_is_som_5728m()		1
+#define board_has_som350()		1
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+#include <cpsw.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define GPIO_STATUS_LED		GPIO_TO_PIN(3, 0)
+#define GPIO_PHY_RST GPIO_TO_PIN(4, 25)
+
+#define SYSINFO_BOARD_NAME_MAX_LEN	45
+
+#define TPS65903X_PRIMARY_SECONDARY_PAD2	0xFB
+#define TPS65903X_PAD2_POWERHOLD_MASK		0x20
+
+const struct omap_sysinfo sysinfo = {
+	"Board: UNKNOWN(SoM-5728M)\n"
+};
+
+int misc_init_r(void)
+{
+#ifdef CONFIG_PALMAS_POWER
+        palmas_init_settings();
+#endif
+        omap_die_id_usbethaddr();
+        return 0;
+}
+
+__weak void gpi2c_init(void)
+{
+}
+
+static const struct dmm_lisa_map_regs som_5728m_lisa_regs = {
+    .dmm_lisa_map_2 = 0x80600100,
+    .dmm_lisa_map_3 = 0xff020100,
+    .is_ma_present  = 0x1
+};
+
+void emif_get_dmm_regs(const struct dmm_lisa_map_regs **dmm_lisa_regs)
+{
+    *dmm_lisa_regs = &som_5728m_lisa_regs;
+}
+
+static const struct emif_regs som_5728m_emif1_ddr3_532mhz_emif_regs = {
+	.sdram_config_init		= 0x61852b32,
+	.sdram_config			= 0x61852b32,
+	.sdram_config2			= 0x00000000,
+	.ref_ctrl			= 0x00004111,
+	.ref_ctrl_final			= 0x0000103d,
+	.sdram_tim1			= 0xceef266b,
+	.sdram_tim2			= 0x308f7fda,
+	.sdram_tim3			= 0x407f88a8,
+	.read_idle_ctrl			= 0x00050000,
+	.zq_config			= 0x5007190b,
+	.temp_alert_config		= 0x00000000,
+	.emif_ddr_phy_ctlr_1_init 	= 0x0024400d,
+	.emif_ddr_phy_ctlr_1		= 0x0e24400d,
+	.emif_ddr_ext_phy_ctrl_1 	= 0x10040100,
+	.emif_ddr_ext_phy_ctrl_2 	= 0x00910091,
+	.emif_ddr_ext_phy_ctrl_3 	= 0x00950095,
+	.emif_ddr_ext_phy_ctrl_4 	= 0x009b009b,
+	.emif_ddr_ext_phy_ctrl_5 	= 0x009e009e,
+	.emif_rd_wr_lvl_rmp_win		= 0x00000000,
+	.emif_rd_wr_lvl_rmp_ctl		= 0x80000000,
+	.emif_rd_wr_lvl_ctl		    = 0x00000000,
+	.emif_rd_wr_exec_thresh		= 0x00000305
+};
+
+/* Ext phy ctrl regs 1-35 */
+static const u32 som_5728m_emif1_ddr3_ext_phy_ctrl_const_regs[] = {
+	0x10040100,
+	0x00910091,
+	0x00950095,
+	0x009B009B,
+	0x009E009E,
+	0x00980098,
+	0x00340034,
+	0x00350035,
+	0x00340034,
+	0x00310031,
+	0x00340034,
+	0x007F007F,
+	0x007F007F,
+	0x007F007F,
+	0x007F007F,
+	0x007F007F,
+	0x00480048,
+	0x004A004A,
+	0x00520052,
+	0x00550055,
+	0x00500050,
+	0x00000000,
+	0x00600020,
+	0x40011080,
+	0x08102040,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0,
+	0x0
+};
+
+
+void emif_get_reg_dump(u32 emif_nr, const struct emif_regs **regs)
+{
+    switch (emif_nr) {
+	case 1:
+		*regs = &som_5728m_emif1_ddr3_532mhz_emif_regs;
+		break;
+	}
+}
+
+
+void emif_get_ext_phy_ctrl_const_regs(u32 emif_nr, const u32 **regs, u32 *size)
+{
+	switch (emif_nr) {
+	case 1:
+		*regs = som_5728m_emif1_ddr3_ext_phy_ctrl_const_regs;
+		*size = ARRAY_SIZE(som_5728m_emif1_ddr3_ext_phy_ctrl_const_regs);
+		break;
+	}
+}
+
+struct vcores_data som_5728m_volts = {
+	.mpu.value[OPP_NOM]	= VDD_MPU_DRA7_NOM,
+	.mpu.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_MPU_NOM,
+	.mpu.efuse.reg_bits     = DRA752_EFUSE_REGBITS,
+	.mpu.addr		= TPS659038_REG_ADDR_SMPS12,
+	.mpu.pmic		= &tps659038,
+	.mpu.abb_tx_done_mask	= OMAP_ABB_MPU_TXDONE_MASK,
+
+	.eve.value[OPP_NOM]	= VDD_EVE_DRA7_NOM,
+	.eve.value[OPP_OD]	= VDD_EVE_DRA7_OD,
+	.eve.value[OPP_HIGH]	= VDD_EVE_DRA7_HIGH,
+	.eve.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_DSPEVE_NOM,
+	.eve.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_DSPEVE_OD,
+	.eve.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_DSPEVE_HIGH,
+	.eve.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.eve.addr		= TPS659038_REG_ADDR_SMPS45,
+	.eve.pmic		= &tps659038,
+	.eve.abb_tx_done_mask	= OMAP_ABB_EVE_TXDONE_MASK,
+
+	.gpu.value[OPP_NOM]	= VDD_GPU_DRA7_NOM,
+	.gpu.value[OPP_OD]	= VDD_GPU_DRA7_OD,
+	.gpu.value[OPP_HIGH]	= VDD_GPU_DRA7_HIGH,
+	.gpu.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_GPU_NOM,
+	.gpu.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_GPU_OD,
+	.gpu.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_GPU_HIGH,
+	.gpu.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.gpu.addr		= TPS659038_REG_ADDR_SMPS45,
+	.gpu.pmic		= &tps659038,
+	.gpu.abb_tx_done_mask	= OMAP_ABB_GPU_TXDONE_MASK,
+
+	.core.value[OPP_NOM]	= VDD_CORE_DRA7_NOM,
+	.core.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_CORE_NOM,
+	.core.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.core.addr		= TPS659038_REG_ADDR_SMPS6,
+	.core.pmic		= &tps659038,
+
+	.iva.value[OPP_NOM]	= VDD_IVA_DRA7_NOM,
+	.iva.value[OPP_OD]	= VDD_IVA_DRA7_OD,
+	.iva.value[OPP_HIGH]	= VDD_IVA_DRA7_HIGH,
+	.iva.efuse.reg[OPP_NOM]	= STD_FUSE_OPP_VMIN_IVA_NOM,
+	.iva.efuse.reg[OPP_OD]	= STD_FUSE_OPP_VMIN_IVA_OD,
+	.iva.efuse.reg[OPP_HIGH]	= STD_FUSE_OPP_VMIN_IVA_HIGH,
+	.iva.efuse.reg_bits	= DRA752_EFUSE_REGBITS,
+	.iva.addr		= TPS659038_REG_ADDR_SMPS45,
+	.iva.pmic		= &tps659038,
+	.iva.abb_tx_done_mask	= OMAP_ABB_IVA_TXDONE_MASK,
+};
+
+int get_voltrail_opp(int rail_offset)
+{
+	int opp;
+
+	switch (rail_offset) {
+	case VOLT_MPU:
+		opp = DRA7_MPU_OPP;
+		break;
+	case VOLT_CORE:
+		opp = DRA7_CORE_OPP;
+		break;
+	case VOLT_GPU:
+		opp = DRA7_GPU_OPP;
+		break;
+	case VOLT_EVE:
+		opp = DRA7_DSPEVE_OPP;
+		break;
+	case VOLT_IVA:
+		opp = DRA7_IVA_OPP;
+		break;
+	default:
+		opp = OPP_NOM;
+	}
+
+	return opp;
+}
+
+
+#ifdef CONFIG_SPL_BUILD
+/* No env to setup for SPL */
+static inline void setup_board_eeprom_env(void) { }
+
+/* Override function to read eeprom information */
+void do_board_detect(void)
+{
+}
+
+void board_boot_order(u32 *spl_boot_list)
+{
+	spl_boot_list[0] = spl_boot_device();
+	if (spl_boot_list[0] != BOOT_DEVICE_SPI)
+		spl_boot_list[1] = BOOT_DEVICE_SPI;
+}
+
+#else	/* CONFIG_SPL_BUILD */
+
+/* Override function to read eeprom information: actual i2c read done by SPL*/
+void do_board_detect(void)
+{
+	char *bname = NULL;
+	int rc;
+
+	if (board_is_som_5728m())
+		if (board_has_som350())
+			bname = "SoM-5728M w/ 350ES";
+		else
+			bname = "SoM-5728M";
+	else
+		bname = "EMAC SoM";
+
+	if (bname)
+		snprintf(sysinfo.board_string, SYSINFO_BOARD_NAME_MAX_LEN,
+			 "Board: %s\n", bname);
+}
+
+static void setup_board_eeprom_env(void)
+{
+	char *name = "emac_som_5728m";
+	int rc;
+
+	if (board_is_som_5728m()) {
+		if (board_has_som350())
+			name = "emacsom_5728m_som350es";
+		else
+			name = "emac_som_5728m";
+	} else {
+		printf("Unidentified dtb compatibility\n");
+	}
+	env_set("board_name", name);
+}
+
+#endif	/* CONFIG_SPL_BUILD */
+
+void vcores_init(void)
+{
+	*omap_vcores = &som_5728m_volts;
+}
+
+void hw_data_init(void)
+{
+	*prcm = &dra7xx_prcm;
+	if (is_dra72x())
+		*dplls_data = &dra72x_dplls;
+	else if (is_dra76x())
+		*dplls_data = &dra76x_dplls;
+	else
+		*dplls_data = &dra7xx_dplls;
+	*ctrl = &dra7xx_ctrl;
+}
+
+int board_init(void)
+{
+	gpmc_init();
+	gd->bd->bi_boot_params = (CFG_SYS_SDRAM_BASE + 0x100);
+
+	return 0;
+}
+
+#if CONFIG_IS_ENABLED(DM_USB) && CONFIG_IS_ENABLED(OF_CONTROL)
+static int device_okay(const char *path)
+{
+	int node;
+
+	node = fdt_path_offset(gd->fdt_blob, path);
+	if (node < 0)
+		return 0;
+
+	return fdtdec_get_is_enabled(gd->fdt_blob, node);
+}
+#endif
+
+int board_late_init(void)
+{
+	setup_board_eeprom_env();
+	u8 val;
+	struct udevice *dev;
+
+	/*
+	 * DEV_CTRL.DEV_ON = 1 please - else palmas switches off in 8 seconds
+	 * This is the POWERHOLD-in-Low behavior.
+	 */
+	palmas_i2c_write_u8(TPS65903X_CHIP_P1, 0xA0, 0x1);
+
+	/*
+	 * Default FIT boot on HS devices. Non FIT images are not allowed
+	 * on HS devices.
+	 */
+	if (get_device_type() == HS_DEVICE)
+		env_set("boot_fit", "1");
+
+	/*
+	 * Set the GPIO7 Pad to POWERHOLD. This has higher priority
+	 * over DEV_CTRL.DEV_ON bit. This can be reset in case of
+	 * PMIC Power off. So to be on the safer side set it back
+	 * to POWERHOLD mode irrespective of the current state.
+	 */
+	palmas_i2c_read_u8(TPS65903X_CHIP_P1, TPS65903X_PRIMARY_SECONDARY_PAD2,
+			   &val);
+	val = val | TPS65903X_PAD2_POWERHOLD_MASK;
+	palmas_i2c_write_u8(TPS65903X_CHIP_P1, TPS65903X_PRIMARY_SECONDARY_PAD2,
+			    val);
+
+	omap_die_id_serial();
+
+	/* Just probe the potentially supported cdce913 device */
+	uclass_get_device(UCLASS_CLK, 0, &dev);
+
+	if (board_is_som_5728m())
+		env_set("console", "ttyS0,115200n8");
+
+#if CONFIG_IS_ENABLED(DM_USB) && CONFIG_IS_ENABLED(OF_CONTROL)
+	if (device_okay("/ocp/omap_dwc3_1@48880000"))
+		enable_usb_clocks(0);
+	if (device_okay("/ocp/omap_dwc3_2@488c0000"))
+		enable_usb_clocks(1);
+#endif
+	return 0;
+}
+
+int last_stage_init(void) {
+	udelay(100000);
+	gpio_request(GPIO_PHY_RST, "phy_rst");
+	gpio_direction_output(GPIO_PHY_RST, 0);
+	udelay(500000);
+	gpio_direction_output(GPIO_PHY_RST, 1);
+	udelay(3000000);
+	return 0;
+}
+
+void set_muxconf_regs(void)
+{
+	do_set_mux32((*ctrl)->control_padconf_core_base,
+		     early_padconf, ARRAY_SIZE(early_padconf));
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+	do_set_mux32((*ctrl)->control_padconf_core_base,
+		     emmc_padconf, ARRAY_SIZE(emmc_padconf));
+#endif
+}
+
+#ifdef CONFIG_IODELAY_RECALIBRATION
+void recalibrate_iodelay(void)
+{
+	const struct pad_conf_entry *pconf;
+	const struct iodelay_cfg_entry *iod, *delta_iod;
+	int pconf_sz, iod_sz, delta_iod_sz = 0;
+	int ret;
+
+	iod = iodelay_cfg_array_som_5728m;
+	iod_sz = ARRAY_SIZE(iodelay_cfg_array_som_5728m);
+
+	/* Setup I/O isolation */
+	ret = __recalibrate_iodelay_start();
+	if (ret)
+		goto err;
+
+	/* Do the muxing here */
+	/* Common for SoM-5728M */
+	if (board_is_som_5728m()) {
+		pconf = core_padconf_array_essential_som_5728m;
+		pconf_sz = ARRAY_SIZE(core_padconf_array_essential_som_5728m);
+		do_set_mux32((*ctrl)->control_padconf_core_base, pconf, pconf_sz);
+	}
+
+	/* Setup IOdelay configuration */
+	ret = do_set_iodelay((*ctrl)->iodelay_config_base, iod, iod_sz);
+	if (delta_iod_sz)
+		ret = do_set_iodelay((*ctrl)->iodelay_config_base, delta_iod,
+				     delta_iod_sz);
+
+err:
+	/* Closeup.. remove isolation */
+	__recalibrate_iodelay_end(ret);
+}
+#endif
+
+#if defined(CONFIG_MMC)
+int board_mmc_init(struct bd_info *bis)
+{
+	omap_mmc_init(0, 0, 0, -1, -1);
+	omap_mmc_init(1, 0, 0, -1, -1);
+	return 0;
+}
+
+static const struct mmc_platform_fixups am57x_es1_1_mmc1_fixups = {
+	.hw_rev = "rev11",
+	.unsupported_caps = MMC_CAP(MMC_HS_200) |
+			    MMC_CAP(UHS_SDR104),
+	.max_freq = 96000000,
+};
+
+static const struct mmc_platform_fixups am57x_es1_1_mmc23_fixups = {
+	.hw_rev = "rev11",
+	.unsupported_caps = MMC_CAP(MMC_HS_200) |
+			    MMC_CAP(UHS_SDR104) |
+			    MMC_CAP(UHS_SDR50),
+	.max_freq = 48000000,
+};
+
+const struct mmc_platform_fixups *platform_fixups_mmc(uint32_t addr)
+{
+	switch (omap_revision()) {
+	case DRA752_ES1_0:
+	case DRA752_ES1_1:
+		if (addr == OMAP_HSMMC1_BASE)
+			return &am57x_es1_1_mmc1_fixups;
+		else
+			return &am57x_es1_1_mmc23_fixups;
+	default:
+		return NULL;
+	}
+}
+#endif
+
+#ifdef CONFIG_DRIVER_TI_CPSW
+
+/* Delay value to add to calibrated value */
+#define RGMII0_TXCTL_DLY_VAL		((0x3 << 5) + 0x8)
+#define RGMII0_TXD0_DLY_VAL		((0x3 << 5) + 0x8)
+#define RGMII0_TXD1_DLY_VAL		((0x3 << 5) + 0x2)
+#define RGMII0_TXD2_DLY_VAL		((0x4 << 5) + 0x0)
+#define RGMII0_TXD3_DLY_VAL		((0x4 << 5) + 0x0)
+#define VIN2A_D13_DLY_VAL		((0x3 << 5) + 0x8)
+#define VIN2A_D17_DLY_VAL		((0x3 << 5) + 0x8)
+#define VIN2A_D16_DLY_VAL		((0x3 << 5) + 0x2)
+#define VIN2A_D15_DLY_VAL		((0x4 << 5) + 0x0)
+#define VIN2A_D14_DLY_VAL		((0x4 << 5) + 0x0)
+
+static void cpsw_control(int enabled)
+{
+	/* VTP can be added here */
+}
+
+static struct cpsw_slave_data cpsw_slaves[] = {
+	{
+		.slave_reg_ofs	= CPSW_SLAVE0_OFFSET,
+		.sliver_reg_ofs	= CPSW_SLIVER0_OFFSET,
+		.phy_addr	= 4,
+		.phy_if		= PHY_INTERFACE_MODE_RGMII,
+	},
+};
+
+static struct cpsw_platform_data cpsw_data = {
+	.mdio_base		= CPSW_MDIO_BASE,
+	.cpsw_base		= CPSW_BASE,
+	.mdio_div		= CPSW_MDIO_DIV,
+	.channels		= 8,
+	.cpdma_reg_ofs		= CPSW_CPDMA_OFFSET,
+	.slaves			= 1,
+	.slave_data		= cpsw_slaves,
+	.ale_reg_ofs		= CPSW_ALE_OFFSET,
+	.ale_entries		= 1024,
+	.host_port_reg_ofs	= CPSW_HOST_PORT_OFFSET,
+	.hw_stats_reg_ofs	= CPSW_HW_STATS,
+	.bd_ram_ofs		= CPSW_BD_OFFSET,
+	.mac_control		= (1 << 5),
+	.control		= cpsw_control,
+	.host_port_num		= 0,
+	.version		= CPSW_CTRL_VERSION_2,
+};
+
+static u64 mac_to_u64(u8 mac[6])
+{
+	int i;
+	u64 addr = 0;
+
+	for (i = 0; i < 6; i++) {
+		addr <<= 8;
+		addr |= mac[i];
+	}
+
+	return addr;
+}
+
+static void u64_to_mac(u64 addr, u8 mac[6])
+{
+	mac[5] = addr;
+	mac[4] = addr >> 8;
+	mac[3] = addr >> 16;
+	mac[2] = addr >> 24;
+	mac[1] = addr >> 32;
+	mac[0] = addr >> 40;
+}
+
+int board_eth_init(struct bd_info *bis)
+{
+	int ret;
+	uint8_t mac_addr[6];
+	uint32_t mac_hi, mac_lo;
+	uint32_t ctrl_val;
+	int i;
+	u64 mac1, mac2;
+	u8 mac_addr1[6], mac_addr2[6];
+	int num_macs;
+
+	/* try reading mac address from efuse */
+	mac_lo = readl((*ctrl)->control_core_mac_id_0_lo);
+	mac_hi = readl((*ctrl)->control_core_mac_id_0_hi);
+	mac_addr[0] = (mac_hi & 0xFF0000) >> 16;
+	mac_addr[1] = (mac_hi & 0xFF00) >> 8;
+	mac_addr[2] = mac_hi & 0xFF;
+	mac_addr[3] = (mac_lo & 0xFF0000) >> 16;
+	mac_addr[4] = (mac_lo & 0xFF00) >> 8;
+	mac_addr[5] = mac_lo & 0xFF;
+
+	if (!env_get("ethaddr")) {
+		printf("<ethaddr> not set. Validating first E-fuse MAC\n");
+
+		if (is_valid_ethaddr(mac_addr))
+			eth_env_set_enetaddr("ethaddr", mac_addr);
+	}
+
+	ctrl_val = readl((*ctrl)->control_core_control_io1) & (~0x33);
+	ctrl_val |= 0x22;
+	writel(ctrl_val, (*ctrl)->control_core_control_io1);
+
+	cpsw_data.slave_data[0].phy_addr = 4;
+
+	ret = cpsw_register(&cpsw_data);
+	if (ret < 0)
+		printf("Error %d registering CPSW switch\n", ret);
+
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+/* VTT regulator enable */
+static inline void status_led_enable(void)
+{
+	if (omap_hw_init_context() == OMAP_INIT_CONTEXT_UBOOT_AFTER_SPL)
+		return;
+
+	gpio_request(GPIO_STATUS_LED, "status");
+	gpio_direction_output(GPIO_STATUS_LED, 0);
+}
+
+int board_early_init_f(void)
+{
+	status_led_enable();
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_OF_LIBFDT) && defined(CONFIG_OF_BOARD_SETUP)
+int ft_board_setup(void *blob, struct bd_info *bd)
+{
+	ft_cpu_setup(blob, bd);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SPL_LOAD_FIT
+int board_fit_config_name_match(const char *name)
+{
+	if (board_is_som_5728m()) {
+		if (!strcmp(name, "emac-som_5728m-350es")){
+			return 0;
+		}
+	}
+	return -1;
+}
+#endif
+
+#ifdef CONFIG_SUPPORT_EMMC_BOOT
+static int board_bootmode_has_emmc(void)
+{
+	/* Check that boot mode is same as BBAI */
+	if (gd->arch.omap_boot_mode != 2)
+		return -EIO;
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TI_SECURE_DEVICE
+void board_fit_image_post_process(const void *fit, int node, void **p_image,
+				  size_t *p_size)
+{
+	secure_boot_verify_image(p_image, p_size);
+}
+
+void board_tee_image_process(ulong tee_image, size_t tee_size)
+{
+	secure_tee_install((u32)tee_image);
+}
+
+U_BOOT_FIT_LOADABLE_HANDLER(IH_TYPE_TEE, board_tee_image_process);
+#endif
diff --git a/board/emacinc/som-5728m/mux_data.h b/board/emacinc/som-5728m/mux_data.h
new file mode 100644
index 0000000000..bdb63548ba
--- /dev/null
+++ b/board/emacinc/som-5728m/mux_data.h
@@ -0,0 +1,367 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2023 EMAC Incorporated - http://www.emacinc.com
+ *
+ * Author: Brenden Tisler <support@emacinc.com>
+ *
+ * Based on board/ti/am57xx/board.c
+ */
+#ifndef _MUX_DATA_EMACINC_SOM_5728M_H_
+#define _MUX_DATA_EMACINC_SOM_5728M_H_
+
+#include <asm/arch/mux_dra7xx.h>
+
+const struct pad_conf_entry early_padconf[] = {
+	/* Console UART */
+	{UART3_RXD, (M0 | PIN_INPUT | SLEWCONTROL)},	/* V2 uart3_rxd.uart3_rxd */
+    {UART3_TXD, (M0 | PIN_OUTPUT | SLEWCONTROL)},	/* Y1 uart3_txd.uart3_txd */
+};
+
+const struct pad_conf_entry emmc_padconf[] = {
+	{GPMC_A23, (M1 | PIN_INPUT_PULLUP)},		    /*  J7: gpmc_a23.mmc2_clk */
+	{GPMC_CS1, (M1 | PIN_INPUT_PULLUP)},		    /*  H6: gpmc_cs1.mmc2_cmd */
+	{GPMC_A24, (M1 | PIN_INPUT_PULLUP)},		    /*  J4: gpmc_a24.mmc2_dat0 */
+	{GPMC_A25, (M1 | PIN_INPUT_PULLUP)},		    /*  J6: gpmc_a25.mmc2_dat1 */
+	{GPMC_A26, (M1 | PIN_INPUT_PULLUP)},		    /*  H4: gpmc_a26.mmc2_dat2 */
+	{GPMC_A27, (M1 | PIN_INPUT_PULLUP)},		    /*  H5: gpmc_a27.mmc2_dat3 */
+	{GPMC_A19, (M1 | PIN_INPUT_PULLUP)},		    /*  K7: gpmc_a19.mmc2_dat4 */
+	{GPMC_A20, (M1 | PIN_INPUT_PULLUP)},		    /*  M7: gpmc_a20.mmc2_dat5 */
+	{GPMC_A21, (M1 | PIN_INPUT_PULLUP)},		    /*  J5: gpmc_a21.mmc2_dat6 */
+	{GPMC_A22, (M1 | PIN_INPUT_PULLUP)},		    /*  K6: gpmc_a22.mmc2_dat7 */
+	// MMC1
+	{MMC1_CLK, (M0 | PIN_INPUT)},	/* W6 mmc1_clk.mmc1_clk */
+    {MMC1_CMD, (M0 | PIN_INPUT)},	/* Y6 mmc1_cmd.mmc1_cmd */
+    {MMC1_DAT0, (M0 | PIN_INPUT)},	/* AA6 mmc1_dat0.mmc1_dat0 */
+    {MMC1_DAT1, (M0 | PIN_INPUT)},	/* Y4 mmc1_dat1.mmc1_dat1 */
+    {MMC1_DAT2, (M0 | PIN_INPUT)},	/* AA5 mmc1_dat2.mmc1_dat2 */
+    {MMC1_DAT3, (M0 | PIN_INPUT)},	/* Y3 mmc1_dat3.mmc1_dat3 */
+    {MMC1_SDCD, (M0 | PIN_INPUT | SLEWCONTROL)},	/* W7 mmc1_sdcd.mmc1_sdcd */
+};
+
+const struct pad_conf_entry core_padconf_array_essential_som_5728m[] = {
+	{DCAN1_RX, 0x5000F}, /* G19 dcan1_rx.dcan1_rx */
+	{DCAN1_TX, 0x90000}, /* G20 dcan1_tx.dcan1_tx */
+	{GPIO6_15, 0x5000F}, /* F20 gpio6_15.dcan2_rx */
+	{GPIO6_14, 0x10002}, /* E21 gpio6_14.dcan2_tx */
+	{TMS, 0x50000}, /* F18 tms.tms */
+	{TDI, 0xD0000}, /* D23 tdi.tdi */
+	{TDO, 0x10000}, /* F19 tdo.tdo */
+	{TCLK, 0x50000}, /* E20 tclk.tclk */
+	{TRSTN, 0x50000}, /* D20 trstn.trstn */
+	{RTCK, 0x10000}, /* E18 rtck.rtck */
+	{VIN2A_D2, 0x1000A}, /* D1 vin2a_d2.eCAP1_in_PWM1_out */
+	{VIN2A_CLK0, 0x5000A}, /* E1 vin2a_clk0.eQEP1A_in */
+	{VIN2A_DE0, 0x5000A}, /* G2 vin2a_de0.eQEP1B_in */
+	{VIN2A_FLD0, 0x5000A}, /* H7 vin2a_fld0.eQEP1_index */
+	{VIN2A_D5, 0x5000A}, /* F4 vin2a_d5.eQEP2A_in */
+	{VIN2A_D6, 0x5000A}, /* C1 vin2a_d6.eQEP2B_in */
+	{VIN2A_D7, 0x5000A}, /* E4 vin2a_d7.eQEP2_index */
+	{VIN2A_D8, 0x5000A}, /* F5 vin2a_d8.eQEP2_strobe */
+	{VIN2A_D13, 0x5000A}, /* C2 vin2a_d13.eQEP3A_in */
+	{VIN2A_D14, 0x5000A}, /* C3 vin2a_d14.eQEP3B_in */
+	{VIN2A_D15, 0x5000A}, /* C4 vin2a_d15.eQEP3_index */
+	{VIN2A_D10, (M3 | PIN_OUTPUT | SLEWCONTROL)}, /* D3 vin2a_d10.mdio_mclk */
+	{VIN2A_D11, (M3 | PIN_INPUT | SLEWCONTROL)}, /* F6 vin2a_d11.mdio_d */
+	{RMII_MHZ_50_CLK, (M14 | PIN_INPUT_PULLUP)},	/* RMII_MHZ_50_CLK.gpio5_17 */
+	{RGMII0_RXD1, 0x50100}, /* Y2 rgmii0_rxd1.rgmii0_rxd1 */
+	{RGMII0_RXD2, 0x50100}, /* V3 rgmii0_rxd2.rgmii0_rxd2 */
+	{RGMII0_RXD3, 0x50100}, /* V4 rgmii0_rxd3.rgmii0_rxd3 */
+	{RGMII0_RXD0, 0x50100}, /* W2 rgmii0_rxd0.rgmii0_rxd0 */
+	{RGMII0_TXD0, 0x10100}, /* U6 rgmii0_txd0.rgmii0_txd0 */
+	{RGMII0_TXD1, 0x10100}, /* V6 rgmii0_txd1.rgmii0_txd1 */
+	{RGMII0_TXD2, 0x10100}, /* U7 rgmii0_txd2.rgmii0_txd2 */
+	{RGMII0_TXD3, 0x10100}, /* V7 rgmii0_txd3.rgmii0_txd3 */
+	{RGMII0_TXC, 0x10100}, /* W9 rgmii0_txc.rgmii0_txc */
+	{RGMII0_TXCTL, 0x10100}, /* V9 rgmii0_txctl.rgmii0_txctl */
+	{RGMII0_RXC, 0x50100}, /* U5 rgmii0_rxc.rgmii0_rxc */
+	{RGMII0_RXCTL, 0x50100}, /* V5 rgmii0_rxctl.rgmii0_rxctl */
+	{VIN1A_DE0, 0x5000E}, /* AD9 vin1a_de0.gpio3_0 */
+	{VIN1A_FLD0, 0x5000E}, /* AF9 vin1a_fld0.gpio3_1 */
+	{VIN1A_D0, 0x5000E}, /* AE8 vin1a_d0.gpio3_4 */
+	{VIN1A_D1, 0x5000E}, /* AD8 vin1a_d1.gpio3_5 */
+	{VIN1A_D2, 0x5000E}, /* AG7 vin1a_d2.gpio3_6 */
+	{VIN1A_D3, 0x5000E}, /* AH6 vin1a_d3.gpio3_7 */
+	{VIN1A_D4, 0x5000E}, /* AH3 vin1a_d4.gpio3_8 */
+	{VIN1A_D5, 0x5000E}, /* AH5 vin1a_d5.gpio3_9 */
+	{VIN1A_D6, 0x5000E}, /* AG6 vin1a_d6.gpio3_10 */
+	{VIN1A_D7, 0x5000E}, /* AH4 vin1a_d7.gpio3_11 */
+	{VIN1A_D8, 0x5000E}, /* AG4 vin1a_d8.gpio3_12 */
+	{VIN1A_D9, 0x5000E}, /* AG2 vin1a_d9.gpio3_13 */
+	{VIN1A_D10, 0x5000E}, /* AG3 vin1a_d10.gpio3_14 */
+	{VIN1A_D11, 0x5000E}, /* AG5 vin1a_d11.gpio3_15 */
+	{VIN1A_D12, 0x5000E}, /* AF2 vin1a_d12.gpio3_16 */
+	{VIN1A_D13, 0x5000E}, /* AF6 vin1a_d13.gpio3_17 */
+	{VIN1A_D14, 0x5000E}, /* AF3 vin1a_d14.gpio3_18 */
+	{VIN1A_D15, 0x5000E}, /* AF4 vin1a_d15.gpio3_19 */
+	{VIN1A_D16, 0x5000E}, /* AF1 vin1a_d16.gpio3_20 */
+	{VIN1A_D17, 0x5000E}, /* AE3 vin1a_d17.gpio3_21 */
+	{VIN1A_D18, 0x5000E}, /* AE5 vin1a_d18.gpio3_22 */
+	{VIN1A_D19, 0x5000E}, /* AE1 vin1a_d19.gpio3_23 */
+	{VIN1A_D20, 0x5000E}, /* AE2 vin1a_d20.gpio3_24 */
+	{VIN1A_D21, 0x5000E}, /* AE6 vin1a_d21.gpio3_25 */
+	{VIN1A_D22, 0x5000E}, /* AD2 vin1a_d22.gpio3_26 */
+	{VIN1A_D23, 0x5000E}, /* AD3 vin1a_d23.gpio3_27 */
+	{SPI1_SCLK, 0x5000E}, /* A25 spi1_sclk.gpio7_7 */
+	{SPI1_D1, 0x5000E}, /* F16 spi1_d1.gpio7_8 */
+	{SPI1_D0, 0x5000E}, /* B25 spi1_d0.gpio7_9 */
+	{SPI1_CS0, 0x5000E}, /* A24 spi1_cs0.gpio7_10 */
+	{SPI2_SCLK, 0x5000E}, /* A26 spi2_sclk.gpio7_14 */
+	{SPI2_D1, 0xD000E}, /* B22 spi2_d1.gpio7_15 */
+	{SPI2_CS0, 0xD000E}, /* B24 spi2_cs0.gpio7_17 */
+	{MCASP1_FSX, 0xD000E}, /* D14 mcasp1_fsx.gpio7_30 */
+	{MCASP1_ACLKX, 0x5000E}, /* C14 mcasp1_aclkx.gpio7_31 */
+	{GPIO6_16, 0x50000}, /* F21 gpio6_16.gpio6_16 */
+	{MMC1_SDWP, 0xD000E}, /* Y9 mmc1_sdwp.gpio6_28 */
+	{GPMC_A11, 0x5000E}, /* P9 gpmc_a11.gpio2_1 */
+	{GPMC_CS0, 0x5000E}, /* T1 gpmc_cs0.gpio2_19 */
+	{GPMC_OEN_REN, 0x5000E}, /* M5 gpmc_oen_ren.gpio2_24 */
+	{GPMC_WEN, 0x5000E}, /* M3 gpmc_wen.gpio2_25 */
+	{GPMC_BEN0, 0x5000E}, /* N6 gpmc_ben0.gpio2_26 */
+	{GPMC_BEN1, 0x5000E}, /* M4 gpmc_ben1.gpio2_27 */
+	{GPMC_WAIT0, 0xD000E}, /* N2 gpmc_wait0.gpio2_28 */
+	{VIN1A_CLK0, 0x5000E}, /* AG8 vin1a_clk0.gpio2_30 */
+	{VIN1B_CLK1, 0xD000E}, /* AH7 vin1b_clk1.gpio2_31 */
+	{VOUT1_D2, 0x5000E}, /* F10 vout1_d2.gpio8_2 */
+	{VOUT1_D3, 0x5000E}, /* G11 vout1_d3.gpio8_3 */
+	{VOUT1_D4, 0x5000E}, /* E9 vout1_d4.gpio8_4 */
+	{VOUT1_D5, 0x5000E}, /* F9 vout1_d5.gpio8_5 */
+	{VOUT1_D6, 0x5000E}, /* F8 vout1_d6.gpio8_6 */
+	{VOUT1_D7, 0x5000E}, /* E7 vout1_d7.gpio8_7 */
+	{VOUT1_D10, 0x5000E}, /* D7 vout1_d10.gpio8_10 */
+	{VOUT1_D11, 0x5000E}, /* D8 vout1_d11.gpio8_11 */
+	{VOUT1_D12, 0x5000E}, /* A5 vout1_d12.gpio8_12 */
+	{VOUT1_D13, 0x5000E}, /* C6 vout1_d13.gpio8_13 */
+	{VOUT1_D14, 0x5000E}, /* C8 vout1_d14.gpio8_14 */
+	{VOUT1_D15, 0x5000E}, /* C7 vout1_d15.gpio8_15 */
+	{VOUT1_D18, 0x5000E}, /* A7 vout1_d18.gpio8_18 */
+	{VOUT1_D19, 0x5000E}, /* A8 vout1_d19.gpio8_19 */
+	{VOUT1_D20, 0x5000E}, /* C9 vout1_d20.gpio8_20 */
+	{VOUT1_D21, 0x5000E}, /* A9 vout1_d21.gpio8_21 */
+	{VOUT1_D22, 0x5000E}, /* B9 vout1_d22.gpio8_22 */
+	{VOUT1_D23, 0x5000E}, /* A10 vout1_d23.gpio8_23 */
+	{MCASP1_ACLKR, 0x5000E}, /* B14 mcasp1_aclkr.gpio5_0 */
+	{MCASP1_FSR, 0x5000E}, /* J14 mcasp1_fsr.gpio5_1 */
+	{MCASP1_AXR4, 0x5000E}, /* E12 mcasp1_axr4.gpio5_6 */
+	{MCASP1_AXR5, 0x5000E}, /* F13 mcasp1_axr5.gpio5_7 */
+	{VIN2A_D3, 0x5000E}, /* E2 vin2a_d3.gpio4_4 */
+	{VIN2A_D4, 0x5000E}, /* D2 vin2a_d4.gpio4_5 */
+	{VIN2A_D9, 0x5000E}, /* E6 vin2a_d9.gpio4_10 */
+	{VIN2A_D12, 0x5000E}, /* D5 vin2a_d12.gpio4_13 */
+	{VIN2A_D16, 0x5000E}, /* B2 vin2a_d16.gpio4_24 */
+	{VIN2A_D17, 0x2000E}, /* D6 vin2a_d17.gpio4_25 */
+	{VIN2A_D18, 0x5000E}, /* C5 vin2a_d18.gpio4_26 */
+	{VIN2A_D19, 0x5000E}, /* A3 vin2a_d19.gpio4_27 */
+	{VIN2A_D20, 0x5000E}, /* B3 vin2a_d20.gpio4_28 */
+	{VIN2A_D21, 0x5000E}, /* B4 vin2a_d21.gpio4_29 */
+	{VIN2A_D22, 0x5000E}, /* B5 vin2a_d22.gpio4_30 */
+	{VIN2A_D23, 0x5000E}, /* A4 vin2a_d23.gpio4_31 */
+	{SPI1_CS3, 0xD0006}, /* B20 spi1_cs3.hdmi1_cec */
+	{SPI1_CS2, 0xD0006}, /* B21 spi1_cs2.hdmi1_hpd */
+	{I2C2_SDA, 0x50001}, /* C25 i2c2_sda.hdmi1_ddc_scl */
+	{I2C2_SCL, 0x50001}, /* F17 i2c2_scl.hdmi1_ddc_sda */
+	{I2C1_SCL, 0x50000}, /* C20 i2c1_scl.i2c1_scl */
+	{I2C1_SDA, 0x50000}, /* C21 i2c1_sda.i2c1_sda */
+	{GPMC_CLK, 0x50008}, /* P7 gpmc_clk.i2c3_scl */
+	{GPMC_ADVN_ALE, 0x50008}, /* N1 gpmc_advn_ale.i2c3_sda */
+	{GPMC_A4, 0x50007}, /* P6 gpmc_a4.i2c5_scl */
+	{GPMC_A5, 0x50007}, /* R9 gpmc_a5.i2c5_sda */
+	{MCASP4_FSX, 0x50004}, /* A21 mcasp4_fsx.i2c4_scl */
+	{MCASP4_ACLKX, 0x50004}, /* C18 mcasp4_aclkx.i2c4_sda */
+	{XREF_CLK3, 0x50004}, /* C23 xref_clk3.mcasp8_ahclkx */
+	{MCASP2_AXR6, 0x50001}, /* B17 mcasp2_axr6.mcasp8_aclkx */
+	{MCASP2_AXR7, 0x50001}, /* A17 mcasp2_axr7.mcasp8_fsx */
+	{MCASP2_AXR4, 0x50001}, /* D15 mcasp2_axr4.mcasp8_axr0 */
+	{MCASP2_AXR5, 0x50001}, /* B16 mcasp2_axr5.mcasp8_axr1 */
+	{MCASP5_ACLKX, 0x50000}, /* AA3 mcasp5_aclkx.mcasp5_aclkx */
+	{MCASP5_FSX, 0x50000}, /* AB9 mcasp5_fsx.mcasp5_fsx */
+	{MCASP1_AXR6, 0x50001}, /* C12 mcasp1_axr6.mcasp5_axr2 */
+	{MCASP1_AXR7, 0x50001}, /* D12 mcasp1_axr7.mcasp5_axr3 */
+	{MMC1_CLK, 0x60000}, /* W6 mmc1_clk.mmc1_clk */
+	{MMC1_CMD, 0x60000}, /* Y6 mmc1_cmd.mmc1_cmd */
+	{MMC1_DAT0, 0x60000}, /* AA6 mmc1_dat0.mmc1_dat0 */
+	{MMC1_DAT1, 0x60000}, /* Y4 mmc1_dat1.mmc1_dat1 */
+	{MMC1_DAT2, 0x60000}, /* AA5 mmc1_dat2.mmc1_dat2 */
+	{MMC1_DAT3, 0x60000}, /* Y3 mmc1_dat3.mmc1_dat3 */
+	{MMC1_SDCD, 0xE0000}, /* W7 mmc1_sdcd.mmc1_sdcd */
+	{GPMC_A23, 0x60001}, /* J7 gpmc_a23.mmc2_clk */
+	{GPMC_CS1, 0x60001}, /* H6 gpmc_cs1.mmc2_cmd */
+	{GPMC_A24, 0x60001}, /* J4 gpmc_a24.mmc2_dat0 */
+	{GPMC_A25, 0x60001}, /* J6 gpmc_a25.mmc2_dat1 */
+	{GPMC_A26, 0x60001}, /* H4 gpmc_a26.mmc2_dat2 */
+	{GPMC_A27, 0x60001}, /* H5 gpmc_a27.mmc2_dat3 */
+	{GPMC_A19, 0x60001}, /* K7 gpmc_a19.mmc2_dat4 */
+	{GPMC_A20, 0x60001}, /* M7 gpmc_a20.mmc2_dat5 */
+	{GPMC_A21, 0x60001}, /* J5 gpmc_a21.mmc2_dat6 */
+	{GPMC_A22, 0x60001}, /* K6 gpmc_a22.mmc2_dat7 */
+	{UART1_CTSN, 0x60103}, /* E25 uart1_ctsn.mmc4_clk */
+	{UART1_RTSN, 0x60103}, /* C27 uart1_rtsn.mmc4_cmd */
+	{UART2_RXD, 0x60103}, /* D28 uart2_rxd.mmc4_dat0 */
+	{UART2_TXD, 0x60103}, /* D26 uart2_txd.mmc4_dat1 */
+	{UART2_CTSN, 0x60103}, /* D27 uart2_ctsn.mmc4_dat2 */
+	{UART2_RTSN, 0x60103}, /* C28 uart2_rtsn.mmc4_dat3 */
+	{UART1_RXD, 0xE0003}, /* B27 uart1_rxd.mmc4_sdcd */
+	{RSTOUTN, 0x10000}, /* F23 rstoutn.rstoutn */
+	{RESETN, 0x50000}, /* E23 resetn.resetn */
+	{XREF_CLK2, 0x50000}, /* B26 xref_clk2.xref_clk2 */
+	{MCASP5_AXR1, 0x5000B}, /* AA4 mcasp5_axr1.pr2_mdio_data */
+	{MCASP5_AXR0, 0x1000B}, /* AB3 mcasp5_axr0.pr2_mdio_mdclk */
+	{MCASP1_AXR1, 0xD000B}, /* F12 mcasp1_axr1.pr2_mii_mt0_clk */
+	{MCASP1_AXR8, 0x9000B}, /* B12 mcasp1_axr8.pr2_mii0_txen */
+	{MCASP1_AXR9, 0x9000B}, /* A11 mcasp1_axr9.pr2_mii0_txd3 */
+	{MCASP1_AXR10, 0x9000B}, /* B13 mcasp1_axr10.pr2_mii0_txd2 */
+	{MCASP1_AXR11, 0x9000B}, /* A12 mcasp1_axr11.pr2_mii0_txd1 */
+	{MCASP1_AXR12, 0x9000B}, /* E14 mcasp1_axr12.pr2_mii0_txd0 */
+	{MCASP1_AXR14, 0xD000B}, /* G14 mcasp1_axr14.pr2_mii0_rxdv */
+	{MCASP1_AXR13, 0xD000B}, /* A13 mcasp1_axr13.pr2_mii_mr0_clk */
+	{MCASP1_AXR15, 0xD000B}, /* F14 mcasp1_axr15.pr2_mii0_rxd3 */
+	{MCASP2_ACLKX, 0x5000B}, /* A19 mcasp2_aclkx.pr2_mii0_rxd2 */
+	{MCASP3_ACLKX, 0x5000B}, /* B18 mcasp3_aclkx.pr2_mii0_crs */
+	{MCASP1_AXR0, 0xD000B}, /* G12 mcasp1_axr0.pr2_mii0_rxer */
+	{MCASP2_FSX, 0xD000B}, /* A18 mcasp2_fsx.pr2_mii0_rxd1 */
+	{MCASP2_AXR2, 0xD000B}, /* C15 mcasp2_axr2.pr2_mii0_rxd0 */
+	{MCASP3_FSX, 0xD000B}, /* F15 mcasp3_fsx.pr2_mii0_col */
+	{MCASP2_AXR3, 0xD000B}, /* A16 mcasp2_axr3.pr2_mii0_rxlink */
+	{GPIO6_10, 0x5000B}, /* AC5 gpio6_10.pr2_mii_mt1_clk */
+	{GPIO6_11, 0x1000B}, /* AB4 gpio6_11.pr2_mii1_txen */
+	{MMC3_CLK, 0x1000B}, /* AD4 mmc3_clk.pr2_mii1_txd3 */
+	{MMC3_CMD, 0x1000B}, /* AC4 mmc3_cmd.pr2_mii1_txd2 */
+	{MMC3_DAT0, 0x1000B}, /* AC7 mmc3_dat0.pr2_mii1_txd1 */
+	{MMC3_DAT1, 0x1000B}, /* AC6 mmc3_dat1.pr2_mii1_txd0 */
+	{MMC3_DAT3, 0x5000B}, /* AC3 mmc3_dat3.pr2_mii1_rxdv */
+	{MMC3_DAT2, 0x5000B}, /* AC9 mmc3_dat2.pr2_mii_mr1_clk */
+	{MMC3_DAT4, 0x5000B}, /* AC8 mmc3_dat4.pr2_mii1_rxd3 */
+	{MMC3_DAT5, 0x5000B}, /* AD6 mmc3_dat5.pr2_mii1_rxd2 */
+	{XREF_CLK1, 0x5000B}, /* E17 xref_clk1.pr2_mii1_crs */
+	{MCASP3_AXR0, 0xD000B}, /* B19 mcasp3_axr0.pr2_mii1_rxer */
+	{MMC3_DAT6, 0x5000B}, /* AB8 mmc3_dat6.pr2_mii1_rxd1 */
+	{MMC3_DAT7, 0x5000B}, /* AB5 mmc3_dat7.pr2_mii1_rxd0 */
+	{XREF_CLK0, 0x5000B}, /* D18 xref_clk0.pr2_mii1_col */
+	{MCASP3_AXR1, 0xD000B}, /* C17 mcasp3_axr1.pr2_mii1_rxlink */
+	{GPMC_A18, 0x10101}, /* R2 gpmc_a18.qspi1_sclk */
+	{GPMC_A13, 0x50101}, /* R3 gpmc_a13.qspi1_rtclk */
+	{GPMC_CS2, 0x20101}, /* P2 gpmc_cs2.qspi1_cs0 */
+	{GPMC_A16, 0x10101}, /* U1 gpmc_a16.qspi1_d0 */
+	{GPMC_A17, 0x50101}, /* P3 gpmc_a17.qspi1_d1 */
+	{RTC_PORZ, 0x50000}, /* AB17 rtc_porz.rtc_porz */
+	{ON_OFF, 0x10000}, /* Y11 on_off.on_off */
+	{SPI1_CS1, 0x10002}, /* A22 spi1_cs1.sata1_led */
+	{VOUT1_VSYNC, 0x50008}, /* E11 vout1_vsync.spi3_sclk */
+	{VOUT1_HSYNC, 0x50008}, /* C11 vout1_hsync.spi3_d0 */
+	{VOUT1_DE, 0x50008}, /* B10 vout1_de.spi3_d1 */
+	{VOUT1_CLK, 0x2000E}, /* D11 vout1_clk.spi3_cs0 */
+	{VOUT1_FLD, 0x2000E}, /* B11 vout1_fld.spi3_cs1 */
+	{VOUT1_D0, 0x2000E}, /* F11 vout1_d0.spi3_cs2 */
+	{VIN2A_HSYNC0, 0x50008}, /* G1 vin2a_hsync0.spi4_sclk */
+	{VIN2A_D0, 0x50008}, /* F2 vin2a_d0.spi4_d0 */
+	{VIN2A_VSYNC0, 0x50008}, /* G6 vin2a_vsync0.spi4_d1 */
+	{VIN2A_D1, 0x2000E}, /* F3 vin2a_d1.spi4_cs0 */
+	{GPMC_A12, 0x2000E}, /* P4 gpmc_a12.spi4_cs1 */
+	{GPMC_A14, 0x2000E}, /* T2 gpmc_a14.spi4_cs3 */
+	{VOUT1_D8, 0x50002}, /* E8 vout1_d8.uart6_rxd */
+	{VOUT1_D9, 0x10002}, /* D9 vout1_d9.uart6_txd */
+	{MCASP1_AXR2, 0x50003}, /* G13 mcasp1_axr2.uart6_ctsn */
+	{MCASP1_AXR3, 0x10003}, /* J11 mcasp1_axr3.uart6_rtsn */
+	{VOUT1_D16, 0x50002}, /* B7 vout1_d16.uart7_rxd */
+	{VOUT1_D17, 0x10002}, /* B8 vout1_d17.uart7_txd */
+	{VIN1A_HSYNC0, 0x50005}, /* AE9 vin1a_hsync0.uart7_ctsn */
+	{VIN1A_VSYNC0, 0x10005}, /* AF8 vin1a_vsync0.uart7_rtsn */
+	{UART3_RXD, 0xD0000}, /* V2 uart3_rxd.uart3_rxd */
+	{UART3_TXD, 0x90000}, /* Y1 uart3_txd.uart3_txd */
+	{MDIO_D, 0xD0001}, /* U4 mdio_d.uart3_ctsn */
+	{MDIO_MCLK, 0x90001}, /* V1 mdio_mclk.uart3_rtsn */
+	{GPMC_A6, 0x50007}, /* R5 gpmc_a6.uart8_rxd */
+	{GPMC_A7, 0x10007}, /* P5 gpmc_a7.uart8_txd */
+	{MCASP4_AXR0, 0x50003}, /* G16 mcasp4_axr0.uart8_ctsn */
+	{MCASP4_AXR1, 0x10003}, /* D17 mcasp4_axr1.uart8_rtsn */
+	{SPI2_D0, 0xD0002}, /* G17 spi2_d0.uart5_rxd */
+	{VOUT1_D1, 0x10002}, /* G10 vout1_d1.uart5_txd */
+	{GPMC_A2, 0x50008}, /* T6 gpmc_a2.uart5_ctsn */
+	{GPMC_A3, 0x10008}, /* T7 gpmc_a3.uart5_rtsn */
+	{USB1_DRVVBUS, 0xA0000}, /* AB10 usb1_drvvbus.usb1_drvvbus */
+	{USB2_DRVVBUS, 0x90000}, /* AC10 usb2_drvvbus.usb2_drvvbus */
+	{GPMC_A9, 0x90103}, /* R4 gpmc_a9.vout3_vsync */
+	{GPMC_A8, 0x90103}, /* N7 gpmc_a8.vout3_hsync */
+	{GPMC_CS3, 0x90103}, /* P1 gpmc_cs3.vout3_clk */
+	{GPMC_A10, 0x90103}, /* N9 gpmc_a10.vout3_de */
+	{GPMC_AD0, 0x90103}, /* M6 gpmc_ad0.vout3_d0 */
+	{GPMC_AD1, 0x90103}, /* M2 gpmc_ad1.vout3_d1 */
+	{GPMC_AD2, 0x90103}, /* L5 gpmc_ad2.vout3_d2 */
+	{GPMC_AD3, 0x90103}, /* M1 gpmc_ad3.vout3_d3 */
+	{GPMC_AD4, 0x90103}, /* L6 gpmc_ad4.vout3_d4 */
+	{GPMC_AD5, 0x90103}, /* L4 gpmc_ad5.vout3_d5 */
+	{GPMC_AD6, 0x90103}, /* L3 gpmc_ad6.vout3_d6 */
+	{GPMC_AD7, 0x90103}, /* L2 gpmc_ad7.vout3_d7 */
+	{GPMC_AD8, 0x90103}, /* L1 gpmc_ad8.vout3_d8 */
+	{GPMC_AD9, 0x90103}, /* K2 gpmc_ad9.vout3_d9 */
+	{GPMC_AD10, 0x90103}, /* J1 gpmc_ad10.vout3_d10 */
+	{GPMC_AD11, 0x90103}, /* J2 gpmc_ad11.vout3_d11 */
+	{GPMC_AD12, 0x90103}, /* H1 gpmc_ad12.vout3_d12 */
+	{GPMC_AD13, 0x90103}, /* J3 gpmc_ad13.vout3_d13 */
+	{GPMC_AD14, 0x90103}, /* H2 gpmc_ad14.vout3_d14 */
+	{GPMC_AD15, 0x90103}, /* H3 gpmc_ad15.vout3_d15 */
+	{GPMC_A0, 0x90103}, /* R6 gpmc_a0.vout3_d16 */
+	{GPMC_A1, 0x90103}, /* T9 gpmc_a1.vout3_d17 */
+};
+
+const struct iodelay_cfg_entry iodelay_cfg_array_som_5728m[] = {
+	{0x714, 139, 1081}, /* Y2 CFG_RGMII0_RXD1_IN */
+	{0x720, 195, 1100}, /* V3 CFG_RGMII0_RXD2_IN */
+	{0x72c, 239, 1216}, /* V4 CFG_RGMII0_RXD3_IN */
+	{0x708, 123, 1047}, /* W2 CFG_RGMII0_RXD0_IN */
+	{0x758, 339, 162}, /* U6 CFG_RGMII0_TXD0_OUT */
+	{0x764, 146, 94}, /* V6 CFG_RGMII0_TXD1_OUT */
+	{0x770, 0, 27}, /* U7 CFG_RGMII0_TXD2_OUT */
+	{0x77c, 291, 205}, /* V7 CFG_RGMII0_TXD3_OUT */
+	{0x740, 89, 0}, /* W9 CFG_RGMII0_TXC_OUT */
+	{0x74c, 15, 125}, /* V9 CFG_RGMII0_TXCTL_OUT */
+	{0x6f0, 260, 0}, /* U5 CFG_RGMII0_RXC_IN */
+	{0x6fc, 0, 1412}, /* V5 CFG_RGMII0_RXCTL_IN */
+	{0x840, 0, 0}, /* E25 CFG_UART1_CTSN_IN */
+	{0x848, 0, 0}, /* E25 CFG_UART1_CTSN_OUT */
+	{0x84c, 307, 0}, /* C27 CFG_UART1_RTSN_IN */
+	{0x850, 0, 0}, /* C27 CFG_UART1_RTSN_OEN */
+	{0x854, 0, 0}, /* C27 CFG_UART1_RTSN_OUT */
+	{0x888, 683, 0}, /* D28 CFG_UART2_RXD_IN */
+	{0x88c, 0, 0}, /* D28 CFG_UART2_RXD_OEN */
+	{0x890, 0, 0}, /* D28 CFG_UART2_RXD_OUT */
+	{0x894, 835, 0}, /* D26 CFG_UART2_TXD_IN */
+	{0x898, 0, 0}, /* D26 CFG_UART2_TXD_OEN */
+	{0x89c, 0, 0}, /* D26 CFG_UART2_TXD_OUT */
+	{0x870, 785, 0}, /* D27 CFG_UART2_CTSN_IN */
+	{0x874, 0, 0}, /* D27 CFG_UART2_CTSN_OEN */
+	{0x878, 0, 0}, /* D27 CFG_UART2_CTSN_OUT */
+	{0x87c, 613, 0}, /* C28 CFG_UART2_RTSN_IN */
+	{0x880, 0, 0}, /* C28 CFG_UART2_RTSN_OEN */
+	{0x884, 0, 0}, /* C28 CFG_UART2_RTSN_OUT */
+	{0x30, 0, 0}, /* U3 CFG_RMII_MHZ_50_CLK_IN */
+	{0x30, 0, 0}, /* U3 CFG_RMII_MHZ_50_CLK_IN */
+	{0x188, 590, 0}, /* R2 CFG_GPMC_A18_OUT */
+	{0x144, 0, 0}, /* R3 CFG_GPMC_A13_IN */
+	{0x374, 0, 0}, /* P2 CFG_GPMC_CS2_OUT */
+	{0x168, 2528, 1007}, /* U1 CFG_GPMC_A16_IN */
+	{0x170, 0, 0}, /* U1 CFG_GPMC_A16_OUT */
+	{0x174, 2533, 980}, /* P3 CFG_GPMC_A17_IN */
+	{0x260, 998, 0}, /* R4 CFG_GPMC_A9_OUT */
+	{0x254, 1843, 0}, /* N7 CFG_GPMC_A8_OUT */
+	{0x380, 1505, 1379}, /* P1 CFG_GPMC_CS3_OUT */
+	{0x128, 1157, 0}, /* N9 CFG_GPMC_A10_OUT */
+	{0x26c, 1151, 0}, /* M6 CFG_GPMC_AD0_OUT */
+	{0x2c0, 956, 0}, /* M2 CFG_GPMC_AD1_OUT */
+	{0x2cc, 1222, 0}, /* L5 CFG_GPMC_AD2_OUT */
+	{0x2d8, 875, 0}, /* M1 CFG_GPMC_AD3_OUT */
+	{0x2e4, 1170, 0}, /* L6 CFG_GPMC_AD4_OUT */
+	{0x2f0, 358, 0}, /* L4 CFG_GPMC_AD5_OUT */
+	{0x2fc, 1184, 0}, /* L3 CFG_GPMC_AD6_OUT */
+	{0x308, 908, 0}, /* L2 CFG_GPMC_AD7_OUT */
+	{0x314, 0, 0}, /* L1 CFG_GPMC_AD8_OUT */
+	{0x320, 0, 0}, /* K2 CFG_GPMC_AD9_OUT */
+	{0x278, 1064, 0}, /* J1 CFG_GPMC_AD10_OUT */
+	{0x284, 809, 0}, /* J2 CFG_GPMC_AD11_OUT */
+	{0x290, 1161, 0}, /* H1 CFG_GPMC_AD12_OUT */
+	{0x29c, 524, 0}, /* J3 CFG_GPMC_AD13_OUT */
+	{0x2a8, 632, 0}, /* H2 CFG_GPMC_AD14_OUT */
+	{0x2b4, 1012, 0}, /* H3 CFG_GPMC_AD15_OUT */
+	{0x11c, 565, 267}, /* R6 CFG_GPMC_A0_OUT */
+	{0x1a0, 650, 0}, /* T9 CFG_GPMC_A1_OUT */
+};
+#endif /* _MUX_DATA_EMACINC_SOM_5728M_H_ */
diff --git a/include/configs/emac-som-5728m.h b/include/configs/emac-som-5728m.h
new file mode 100644
index 0000000000..e677f738d7
--- /dev/null
+++ b/include/configs/emac-som-5728m.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2023
+ * EMAC Incorporated.
+ * Brenden Tisler <support@emacinc.com>
+ *
+ * Configuration settings for the EMAC SoM-5728M board.
+ * See ti_omap5_common.h for omap5 common settings.
+ * Based on include/configs/am57xx_evm.h
+ */
+
+#ifndef __CONFIG_AM57XX_SOM_5728M_H
+#define __CONFIG_AM57XX_SOM_5728M_H
+
+#include <environment/ti/dfu.h>
+#include <linux/sizes.h>
+
+#define CONFIG_SYS_NS16550_COM1		UART1_BASE	/* Base EVM has UART0 */
+#define CONFIG_SYS_NS16550_COM2		UART2_BASE	/* UART2 */
+#define CONFIG_SYS_NS16550_COM3		UART3_BASE	/* UART3 */
+
+#ifndef CONFIG_SPL_BUILD
+#define DFUARGS \
+	"dfu_bufsiz=0x10000\0" \
+	DFU_ALT_INFO_MMC \
+	DFU_ALT_INFO_EMMC \
+	DFU_ALT_INFO_RAM \
+	DFU_ALT_INFO_QSPI
+#else
+#ifdef CONFIG_SPL_DFU
+#define DFUARGS \
+	"dfu_bufsiz=0x10000\0" \
+	DFU_ALT_INFO_RAM
+#endif
+#endif
+
+#include <configs/ti_omap5_common.h>
+
+/* CPSW Ethernet */
+#define PHY_ANEG_TIMEOUT	8000	/* PHY needs longer aneg time at 1G */
+
+/* SATA */
+#define CONFG_SCSI_AHCI_PLAT
+#define CONFG_SYS_SCSI_MAX_SCSI_ID	1
+#define CONFG_SYS_SCSI_MAX_LUN		1
+#define CONFG_SYS_SCSI_MAX_DEVICE	(CONFIG_SYS_SCSI_MAX_SCSI_ID * \
+						CONFIG_SYS_SCSI_MAX_LUN)
+
+/*
+ * Default to using SPI for environment, etc.
+ * 0x000000 - 0x040000 : QSPI.SPL (256KiB)
+ * 0x040000 - 0x140000 : QSPI.u-boot (1MiB)
+ * 0x140000 - 0x1C0000 : QSPI.u-boot-spl-os (512KiB)
+ * 0x1C0000 - 0x1D0000 : QSPI.u-boot-env (64KiB)
+ * 0x1D0000 - 0x1E0000 : QSPI.u-boot-env.backup1 (64KiB)
+ * 0x1E0000 - 0x9E0000 : QSPI.kernel (8MiB)
+ * 0x9E0000 - 0x1000000 : USERLAND
+ */
+#define CFG_SYS_SPI_KERNEL_OFFS      0x1E0000
+#define CFG_SYS_SPI_ARGS_OFFS        0x140000
+#define CFG_SYS_SPI_ARGS_SIZE        0x80000
+
+/* SPI SPL */
+
+#endif /* __CONFIG_AM57XX_SOM_5728M_H */
